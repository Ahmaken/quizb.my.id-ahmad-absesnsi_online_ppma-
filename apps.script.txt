// =============================================
// 1. KONFIGURASI & KONSTANTA
// =============================================
const API_BASE_URL = 'https://quizb.my.id/ahmad/absesnsi_online_ppma/api_sync.php';
const API_UPDATE_URL = 'https://quizb.my.id/ahmad/absesnsi_online_ppma/api_update.php';

const LOG_LEVELS = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3
};

let CURRENT_LOG_LEVEL = LOG_LEVELS.INFO;

// =============================================
// 2. FUNGSI BANTU UTAMA
// =============================================
function buatSheet(namaSheet) {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = spreadsheet.getSheetByName(namaSheet);
  
  if (!sheet) {
    sheet = spreadsheet.insertSheet(namaSheet);
  } else {
    sheet.clear();
  }
  
  return sheet;
}

function buatSummarySheet() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = spreadsheet.getSheetByName('API, SUMMARY');
  
  if (!sheet) {
    sheet = spreadsheet.insertSheet('API, SUMMARY', 0);
  }
  
  return sheet;
}

function bersihkanTeks(teks) {
  if (!teks || typeof teks !== 'string') return '';
  
  return teks
    .replace(/^[=+@-]/g, '')
    .replace(/\n/g, ' ')
    .trim();
}

function formatForSheetDisplay(value) {
  if (!value) return '';
  
  const strValue = value.toString();
  if (strValue.length > 10 && /^\d+$/.test(strValue)) {
    return "'" + strValue;
  }
  
  return value;
}

function isLongNumericField(header, value) {
  const numericFields = ['nik', 'nis', 'no_hp', 'nip', 'no_wali'];
  const cleanHeader = header.toLowerCase();
  
  return numericFields.some(field => cleanHeader.includes(field)) && 
         typeof value === 'string' && 
         value.length > 10;
}

function setColumnFormats(sheet, headers) {
  headers.forEach((header, index) => {
    const colNumber = index + 1;
    const cleanHeader = header.toLowerCase();
    
    if (cleanHeader.includes('nik') || cleanHeader.includes('nis') || 
        cleanHeader.includes('nip') || cleanHeader === 'no_hp') {
      const range = sheet.getRange(2, colNumber, sheet.getLastRow() - 1, 1);
      range.setNumberFormat('@');
    }
  });
}

function isRowEmpty(rowData) {
  return rowData.every(cell => 
    cell === '' || cell === null || cell === undefined || cell === ' ' || cell === '  '
  );
}

function getTableName(sheetName) {
  const mapping = {
    'Data_Murid': 'murid',
    'Data_Guru': 'guru',
    'Data_Absensi': 'absensi',
    'Data_Pelanggaran': 'pelanggaran',
    'Data_Perizinan': 'perizinan',
    'Data_Alumni': 'alumni',
    'Data_Users': 'users',
    'Data_Pengaturan_Notifikasi': 'pengaturan_notifikasi',
    'Data_Absensi_Guru': 'absensi_guru',
    'Data_Pengaturan_Absensi_Otomatis': 'pengaturan_absensi_otomatis',
    'Data_Jadwal_Madin': 'jadwal_madin',
    'Data_Login_Attempts': 'login_attempts'
  };
  
  const tableName = mapping[sheetName];
  if (!tableName) {
    throw new Error(`Tidak ada mapping untuk sheet: ${sheetName}`);
  }
  
  return tableName;
}

// =============================================
// 3. FUNGSI ANALISIS & DIAGNOSA
// =============================================
function analyzeSheetsData() {
  const sheetsToPush = ['Data_Guru', 'Data_Murid', 'Data_Alumni', 'Data_Users'];
  const analysis = [];
  
  sheetsToPush.forEach(sheetName => {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    if (sheet) {
      const rowCount = sheet.getLastRow() - 1;
      const hasData = rowCount > 0;
      
      let recommendedChunkSize;
      let delay;
      
      if (rowCount <= 10) {
        recommendedChunkSize = 5;
        delay = 1000;
      } else if (rowCount <= 50) {
        recommendedChunkSize = 10;
        delay = 2000;
      } else if (rowCount <= 200) {
        recommendedChunkSize = 15;
        delay = 3000;
      } else {
        recommendedChunkSize = 20;
        delay = 4000;
      }
      
      analysis.push({
        sheetName: sheetName,
        hasData: hasData,
        rowCount: rowCount,
        recommendedChunkSize: recommendedChunkSize,
        delay: delay
      });
    }
  });
  
  return analysis;
}

function analyzeColumnIssues() {
  try {
    Logger.log('üîç Menganalisis masalah kolom...');
    
    const sheetsToAnalyze = ['Data_Murid', 'Data_Guru', 'Data_Users', 'Data_Alumni'];
    const analysis = [];
    
    sheetsToAnalyze.forEach(sheetName => {
      const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
      if (!sheet) return;
      
      const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
      const issues = [];
      
      headers.forEach(header => {
        if (!header) return;
        
        const cleanHeader = header.toString().toLowerCase().trim();
        
        if ((cleanHeader.includes('kelas_madin') || cleanHeader.includes('kelas_quran') || 
             cleanHeader.includes('kamar')) && !cleanHeader.includes('_id')) {
          issues.push(`${header} ‚Üí seharusnya ${header}_id`);
        }
        
        if (cleanHeader === 'user_id' && sheetName === 'Data_Users') {
          issues.push(`${header} ‚Üí seharusnya id`);
        }
      });
      
      analysis.push({
        sheet: sheetName,
        headers: headers.filter(h => h).length,
        issues: issues,
        hasIssues: issues.length > 0
      });
    });
    
    const sheet = buatSummarySheet();
    sheet.clear();
    
    let row = 1;
    sheet.getRange(row, 1).setValue('üîç ANALISIS MASALAH KOLOM').setFontWeight("bold").setFontSize(16);
    row += 2;
    
    analysis.forEach(item => {
      sheet.getRange(row, 1).setValue(`üìã ${item.sheet}:`).setFontWeight("bold");
      sheet.getRange(row, 2).setValue(`${item.headers} kolom`);
      row++;
      
      if (item.hasIssues) {
        sheet.getRange(row, 1).setValue(`‚ùå Masalah:`).setFontColor('#FF0000');
        item.issues.forEach(issue => {
          sheet.getRange(row, 2).setValue(issue);
          row++;
        });
      } else {
        sheet.getRange(row, 1).setValue(`‚úÖ OK`).setFontColor('#4CAF50');
        row++;
      }
      row++;
    });
    
    sheet.autoResizeColumn(1);
    sheet.autoResizeColumn(2);
    
    Logger.log('Analisis kolom selesai');
    
  } catch (error) {
    Logger.log(`‚ùå Analisis gagal: ${error.toString()}`);
  }
}

function analyzePerformance(realtimeLog) {
  const performance = {
    rating: 'UNKNOWN',
    score: 0,
    metrics: {}
  };
  
  let score = 0;
  let totalMetrics = 0;
  
  // 1. Success Rate (40% weight)
  if (realtimeLog.successRate !== undefined) {
    performance.metrics.successRate = {
      value: realtimeLog.successRate,
      weight: 40,
      score: Math.min(100, realtimeLog.successRate)
    };
    score += (performance.metrics.successRate.score * 40) / 100;
    totalMetrics++;
  }
  
  // 2. Activity Level (30% weight)
  if (realtimeLog.eventsPerHour !== undefined) {
    let activityScore = 0;
    if (realtimeLog.eventsPerHour > 10) activityScore = 100;
    else if (realtimeLog.eventsPerHour > 5) activityScore = 80;
    else if (realtimeLog.eventsPerHour > 1) activityScore = 60;
    else activityScore = 30;
    
    performance.metrics.activityLevel = {
      value: realtimeLog.eventsPerHour,
      weight: 30,
      score: activityScore
    };
    score += (activityScore * 30) / 100;
    totalMetrics++;
  }
  
  // 3. Time Coverage (30% weight)
  if (realtimeLog.timeRange.totalHours > 0) {
    let coverageScore = 0;
    if (realtimeLog.timeRange.totalHours > 168) coverageScore = 100; // > 1 minggu
    else if (realtimeLog.timeRange.totalHours > 72) coverageScore = 80; // > 3 hari
    else if (realtimeLog.timeRange.totalHours > 24) coverageScore = 60; // > 1 hari
    else coverageScore = 30;
    
    performance.metrics.timeCoverage = {
      value: realtimeLog.timeRange.totalHours,
      weight: 30,
      score: coverageScore
    };
    score += (coverageScore * 30) / 100;
    totalMetrics++;
  }
  
  // Hitung final score
  if (totalMetrics > 0) {
    performance.score = Math.round(score);
    
    // Tentukan rating
    if (performance.score >= 90) performance.rating = 'EXCELLENT üèÜ';
    else if (performance.score >= 80) performance.rating = 'GOOD üëç';
    else if (performance.score >= 70) performance.rating = 'FAIR ‚ö†Ô∏è';
    else if (performance.score >= 60) performance.rating = 'NEEDS IMPROVEMENT üîß';
    else performance.rating = 'POOR ‚ùå';
  }
  
  return performance;
}

function analyzeRealtimeLog() {
  const logSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Realtime_Log');
  if (!logSheet || logSheet.getLastRow() <= 1) {
    return { total: 0, message: 'Log kosong' };
  }
  
  const data = logSheet.getDataRange().getValues();
  const headers = data[0];
  const logData = data.slice(1);
  
  const timestampIdx = headers.indexOf('Timestamp');
  const eventTypeIdx = headers.indexOf('Event Type');
  const sheetIdx = headers.indexOf('Sheet');
  const rowIdx = headers.indexOf('Row');
  
  const analysis = {
    totalEntries: logData.length,
    eventTypes: {},
    sheets: {},
    timeRange: {},
    recentActivity: [],
    successRate: 0
  };
  
  let successCount = 0;
  let earliestDate = new Date();
  let latestDate = new Date(0);
  
  logData.forEach((row, index) => {
    const timestamp = row[timestampIdx];
    const eventType = row[eventTypeIdx];
    const sheet = row[sheetIdx];
    const rowNum = row[rowIdx];
    
    analysis.eventTypes[eventType] = (analysis.eventTypes[eventType] || 0) + 1;
    
    if (sheet) {
      analysis.sheets[sheet] = (analysis.sheets[sheet] || 0) + 1;
    }
    
    if (eventType === 'push_success' || eventType === 'sync_success') {
      successCount++;
    }
    
    try {
      const logDate = new Date(timestamp);
      if (logDate < earliestDate) earliestDate = logDate;
      if (logDate > latestDate) latestDate = logDate;
    } catch (e) {}
    
    if (index < 10) {
      analysis.recentActivity.push({
        timestamp: timestamp,
        event: eventType,
        sheet: sheet,
        row: rowNum
      });
    }
  });
  
  analysis.successRate = logData.length > 0 ? 
    Math.round((successCount / logData.length) * 100) : 0;
  
  analysis.timeRange = {
    earliest: earliestDate.toLocaleString(),
    latest: latestDate.toLocaleString(),
    totalHours: Math.round((latestDate - earliestDate) / (1000 * 60 * 60))
  };
  
  if (analysis.timeRange.totalHours > 0) {
    analysis.eventsPerHour = Math.round(logData.length / analysis.timeRange.totalHours);
  }
  
  return analysis;
}

function analyzeErrorLog() {
  const errorSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Error_Log');
  if (!errorSheet || errorSheet.getLastRow() <= 1) {
    return { total: 0, message: 'Tidak ada error' };
  }
  
  const data = errorSheet.getDataRange().getValues();
  const headers = data[0];
  const errorData = data.slice(1);
  
  const analysis = {
    totalErrors: errorData.length,
    errorTypes: {},
    contexts: {},
    sheets: {},
    recentErrors: []
  };
  
  const contextIdx = headers.indexOf('Context');
  const errorIdx = headers.indexOf('Error');
  const sheetIdx = headers.indexOf('Sheet');
  const timestampIdx = headers.indexOf('Timestamp');
  
  errorData.forEach((row, index) => {
    const context = row[contextIdx] || 'Unknown';
    const error = row[errorIdx] || 'Unknown';
    const sheet = row[sheetIdx] || 'Unknown';
    const timestamp = row[timestampIdx];
    
    analysis.errorTypes[context] = (analysis.errorTypes[context] || 0) + 1;
    analysis.sheets[sheet] = (analysis.sheets[sheet] || 0) + 1;
    
    if (index < 5) {
      analysis.recentErrors.push({
        timestamp: timestamp,
        context: context,
        error: error.substring(0, 100),
        sheet: sheet
      });
    }
    
    let errorPattern = 'Other';
    if (error.includes('timeout') || error.includes('Timeout')) errorPattern = 'Timeout';
    else if (error.includes('ReferenceError')) errorPattern = 'ReferenceError';
    else if (error.includes('TypeError')) errorPattern = 'TypeError';
    else if (error.includes('network') || error.includes('Network')) errorPattern = 'Network';
    else if (error.includes('API') || error.includes('api')) errorPattern = 'API';
    
    analysis.contexts[errorPattern] = (analysis.contexts[errorPattern] || 0) + 1;
  });
  
  if (errorData.length > 0) {
    try {
      const firstError = new Date(errorData[0][timestampIdx]);
      const lastError = new Date(errorData[errorData.length - 1][timestampIdx]);
      const days = Math.max(1, (lastError - firstError) / (1000 * 60 * 60 * 24));
      analysis.errorsPerDay = (errorData.length / days).toFixed(2);
    } catch (e) {
      analysis.errorsPerDay = 'N/A';
    }
  }
  
  return analysis;
}

function quickDataCheck() {
  try {
    Logger.log('üîç Quick Data Check...');
    
    const sheetsToCheck = ['Data_Murid', 'Data_Guru', 'Data_Users', 'Data_Alumni'];
    let report = 'üìä QUICK DATA CHECK REPORT\n\n';
    
    sheetsToCheck.forEach(sheetName => {
      const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
      if (sheet) {
        const lastRow = sheet.getLastRow();
        const lastCol = sheet.getLastColumn();
        const dataCount = lastRow - 1;
        
        report += `üìã ${sheetName}:\n`;
        report += `   ‚Ä¢ Baris data: ${dataCount}\n`;
        report += `   ‚Ä¢ Kolom: ${lastCol}\n`;
        
        if (dataCount > 0) {
          const headers = sheet.getRange(1, 1, 1, Math.min(lastCol, 5)).getValues()[0];
          const firstData = sheet.getRange(2, 1, 1, Math.min(lastCol, 3)).getValues()[0];
          
          report += `   ‚Ä¢ Headers: ${headers.join(', ')}\n`;
          report += `   ‚Ä¢ Sample: ${firstData.join(' | ')}\n`;
        } else {
          report += `   ‚Ä¢ ‚ùå TIDAK ADA DATA\n`;
        }
        report += '\n';
      } else {
        report += `üìã ${sheetName}: ‚ùå SHEET TIDAK DITEMUKAN\n\n`;
      }
    });
    
    report += 'üîó TEST KONEKSI API:\n';
    const apiTest = testAPIConnection();
    report += `‚Ä¢ ${apiTest}\n`;
    
    Logger.log(report);
    
    const sheet = buatSummarySheet();
    sheet.clear();
    
    let row = 1;
    const lines = report.split('\n');
    lines.forEach(line => {
      if (line.includes('‚ùå') || line.includes('TIDAK ADA')) {
        sheet.getRange(row, 1).setValue(line).setFontColor('#FF0000');
      } else if (line.includes('‚úÖ') || line.includes('DATA')) {
        sheet.getRange(row, 1).setValue(line).setFontColor('#4CAF50');
      } else {
        sheet.getRange(row, 1).setValue(line);
      }
      row++;
    });
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Quick check selesai - lihat sheet SUMMARY',
      'Data Check',
      5
    );
    
    return report;
    
  } catch (error) {
    const errorMsg = `‚ùå Quick check gagal: ${error.toString()}`;
    Logger.log(errorMsg);
    return errorMsg;
  }
}

function diagnosaSistemLengkap() {
  try {
    let diagnosa = 'üîç HASIL DIAGNOSA SISTEM PPMA\n\n';
    
    diagnosa += '1. üîó TEST KONEKSI DASAR:\n';
    const apiTest = testAPIConnection();
    diagnosa += `   ‚Ä¢ API Sync: ${apiTest}\n`;
    
    diagnosa += '\n2. üìä TEST ENDPOINT SPESIFIK:\n';
    const criticalEndpoints = ['get_murid', 'get_guru', 'get_alumni'];
    
    criticalEndpoints.forEach(endpoint => {
      const result = testSpecificEndpoint(endpoint);
      const status = result.success ? '‚úÖ' : '‚ùå';
      diagnosa += `   ‚Ä¢ ${status} ${endpoint}: ${result.success ? 'OK' : result.error}\n`;
      Utilities.sleep(1000);
    });
    
    diagnosa += '\n3. ‚öôÔ∏è STATUS TRIGGER:\n';
    const triggerStatus = checkEditTrigger();
    diagnosa += `   ‚Ä¢ Edit Trigger: ${triggerStatus ? '‚úÖ Aktif' : '‚ùå Tidak Aktif'}\n`;
    
    diagnosa += '\n4. üìã STATUS SHEETS:\n';
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheets = spreadsheet.getSheets();
    sheets.forEach(sheet => {
      const sheetName = sheet.getName();
      if (!sheetName.includes('SUMMARY')) {
        const dataRange = sheet.getDataRange();
        const numRows = dataRange.getNumRows();
        const numCols = dataRange.getNumColumns();
        diagnosa += `   ‚Ä¢ ${sheetName}: ${numRows-1} baris, ${numCols} kolom\n`;
      }
    });
    
    diagnosa += `\n5. üí° REKOMENDASI:\n`;
    if (apiTest.includes('ERROR')) {
      diagnosa += '   ‚Ä¢ ‚ùå Periksa koneksi internet dan server API\n';
    } else {
      diagnosa += '   ‚Ä¢ ‚úÖ Koneksi API normal\n';
    }
    
    if (!triggerStatus) {
      diagnosa += '   ‚Ä¢ üîß Jalankan "Setup Sistem Lengkap" untuk aktifkan edit trigger\n';
    }
    
    diagnosa += `   ‚Ä¢ üïê Waktu diagnosa: ${new Date().toLocaleString()}`;
    
    const ui = SpreadsheetApp.getUi(); // <-- INI YANG BENAR
    ui.alert('Diagnosa Sistem PPMA', diagnosa, ui.ButtonSet.OK);
    
    return diagnosa;
  } catch (error) {
    const errorMsg = `‚ùå Error diagnosa sistem: ${error.toString()}`;
    const ui = SpreadsheetApp.getActiveSpreadsheet().toast();
    ui.alert('Error Diagnosa', errorMsg, ui.ButtonSet.OK);
    return errorMsg;
  }
}

function diagnosaStrukturDatabase() {
  try {
    Logger.log('üîç Memulai diagnosa struktur database...');
    
    const sheetsToCheck = ['Data_Murid', 'Data_Guru', 'Data_Users', 'Data_Alumni'];
    let diagnosa = 'üîç **DIAGNOSA STRUKTUR DATABASE**\n\n';
    let hasUI = true;
    
    // Test API connection first
    diagnosa += '**TEST KONEKSI API:**\n';
    try {
      const testResult = testAPIConnection();
      diagnosa += `‚Ä¢ API Sync: ${testResult}\n\n`;
    } catch (e) {
      diagnosa += `‚Ä¢ API Sync: ‚ùå Error - ${e.toString()}\n\n`;
    }
    
    for (const sheetName of sheetsToCheck) {
      diagnosa += `**${sheetName}:**\n`;
      
      try {
        const structure = detectAndSyncTableStructure(sheetName);
        
        if (!structure) {
          diagnosa += `   ‚ùå Gagal mendapatkan struktur\n`;
          continue;
        }
        
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
        if (!sheet) {
          diagnosa += `   ‚ùå Sheet tidak ditemukan\n`;
          continue;
        }
        
        const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
        const validHeaders = headers.filter(h => h && h.toString().trim() !== '');
        
        diagnosa += `   üìä Kolom di database: ${structure.dbColumns ? structure.dbColumns.length : 'N/A'}\n`;
        diagnosa += `   üìã Kolom di sheet: ${validHeaders.length}\n`;
        
        if (structure.invalidColumns && structure.invalidColumns.length > 0) {
          diagnosa += `   ‚ùå Kolom tidak valid: ${structure.invalidColumns.join(', ')}\n`;
        } else {
          diagnosa += `   ‚úÖ Semua kolom valid\n`;
        }
        
      } catch (error) {
        diagnosa += `   ‚ùå Error: ${error.toString()}\n`;
      }
      
      diagnosa += `\n`;
    }
    
    // Tampilkan hasil - hanya jika ada UI context
    try {
      const ui = SpreadsheetApp.getUi();
      ui.alert('Diagnosa Struktur Database', diagnosa, ui.ButtonSet.OK);
    } catch (e) {
      // Jika tidak ada UI context, log saja dan tampilkan toast
      Logger.log(diagnosa);
      SpreadsheetApp.getActiveSpreadsheet().toast(
        'Diagnosa selesai - lihat log untuk detail',
        'Diagnosa Struktur Database',
        5
      );
      hasUI = false;
    }
    
    Logger.log('Hasil Diagnosa Struktur:\n' + diagnosa);
    return {diagnosa: diagnosa, hasUI: hasUI};
    
  } catch (error) {
    const errorMsg = `‚ùå Error diagnosa struktur: ${error.toString()}`;
    Logger.log(errorMsg);
    
    try {
      const ui = SpreadsheetApp.getUi();
      ui.alert('Error Diagnosa', errorMsg, ui.ButtonSet.OK);
    } catch (e) {
      SpreadsheetApp.getActiveSpreadsheet().toast(errorMsg, 'Error Diagnosa', 5);
    }
    
    return {error: errorMsg, hasUI: false};
  }
}

function diagnosaErrorDetail() {
  try {
    Logger.log('üîç Memulai diagnosa error detail...');
    
    // Test koneksi API update dengan data test yang sederhana
    const testResults = [];
    
    // Test 1: Koneksi dasar API Update
    testResults.push('1. üîó TEST KONEKSI API UPDATE:');
    try {
      const testData = {
        table: 'guru',
        action: 'update', 
        data: { nama: 'Test Diagnostic' },
        where: { guru_id: 1 }
      };
      
      const options = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        payload: JSON.stringify(testData),
        'muteHttpExceptions': true,
        'timeout': 10000
      };
      
      const response = UrlFetchApp.fetch(API_UPDATE_URL, options);
      const responseCode = response.getResponseCode();
      const responseText = response.getContentText();
      
      testResults.push(`   ‚Ä¢ HTTP Status: ${responseCode}`);
      testResults.push(`   ‚Ä¢ Response: ${responseText.substring(0, 200)}`);
      
      if (responseCode === 200) {
        try {
          const result = JSON.parse(responseText);
          testResults.push(`   ‚Ä¢ JSON Parse: ‚úÖ Berhasil`);
          testResults.push(`   ‚Ä¢ API Success: ${result.success}`);
          if (!result.success) {
            testResults.push(`   ‚Ä¢ Error Message: ${result.error}`);
          }
        } catch (e) {
          testResults.push(`   ‚Ä¢ JSON Parse: ‚ùå Gagal - ${e.toString()}`);
        }
      }
      
    } catch (error) {
      testResults.push(`   ‚Ä¢ ‚ùå Error: ${error.toString()}`);
    }
    
    // Test 2: Cek struktur data di sheet
    testResults.push('\n2. üìä TEST STRUKTUR DATA:');
    const sheetsToCheck = ['Data_Guru', 'Data_Murid'];
    
    sheetsToCheck.forEach(sheetName => {
      const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
      if (sheet) {
        const dataRange = sheet.getDataRange();
        const numRows = dataRange.getNumRows();
        const numCols = dataRange.getNumColumns();
        const headers = sheet.getRange(1, 1, 1, numCols).getValues()[0];
        
        testResults.push(`   ‚Ä¢ ${sheetName}: ${numRows-1} baris, ${numCols} kolom`);
        testResults.push(`     Headers: ${headers.slice(0, 3).join(', ')}...`);
        
        // Cek sample data baris 2
        if (numRows > 1) {
          const sampleRow = sheet.getRange(2, 1, 1, Math.min(numCols, 5)).getValues()[0];
          testResults.push(`     Sample: ${sampleRow.join(' | ')}`);
        }
      } else {
        testResults.push(`   ‚Ä¢ ${sheetName}: ‚ùå Sheet tidak ditemukan`);
      }
    });
    
    // Test 3: Validasi data pertama
    testResults.push('\n3. üß™ VALIDASI DATA PERTAMA:');
    const testSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Data_Guru');
    if (testSheet && testSheet.getLastRow() > 1) {
      const headers = testSheet.getRange(1, 1, 1, testSheet.getLastColumn()).getValues()[0];
      const firstRow = testSheet.getRange(2, 1, 1, testSheet.getLastColumn()).getValues()[0];
      
      const validation = validateRowDataStrict(headers, firstRow);
      testResults.push(`   ‚Ä¢ Validasi: ${validation.isValid ? '‚úÖ Valid' : '‚ùå Invalid'}`);
      if (!validation.isValid) {
        testResults.push(`   ‚Ä¢ Errors: ${validation.errors.join(', ')}`);
      }
      
      const preparedData = prepareDataForUpdateStrict(headers, firstRow, 'Data_Guru');
      testResults.push(`   ‚Ä¢ Prep Data: ${preparedData.isValid ? '‚úÖ Siap' : '‚ùå Gagal'}`);
      if (!preparedData.isValid) {
        testResults.push(`   ‚Ä¢ Prep Error: ${preparedData.error}`);
      }
    }
    
    const diagnosis = testResults.join('\n');
    Logger.log(diagnosis);
    
    // Tampilkan di dialog
    const ui = SpreadsheetApp.getUi();
    ui.alert('üîç Diagnosa Error Detail', diagnosis, ui.ButtonSet.OK);
    
    return diagnosis;
    
  } catch (error) {
    const errorMsg = `‚ùå Error diagnosa: ${error.toString()}`;
    Logger.log(errorMsg);
    return errorMsg;
  }
}

function checkSystemComponents() {
  const triggers = ScriptApp.getProjectTriggers();
  const editTriggers = triggers.filter(t => 
    t.getHandlerFunction().includes('onEdit')
  );
  
  return {
    triggerCount: triggers.length,
    hasEditTrigger: editTriggers.length > 0,
    editTriggers: editTriggers.map(t => t.getHandlerFunction()),
    timestamp: new Date().toLocaleString()
  };
}

function checkDataValidationIssues() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Data_Murid');
  if (!sheet) return;
  
  const dataValidations = sheet.getDataRange().getDataValidations();
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  let issues = [];
  
  for (let row = 0; row < dataValidations.length; row++) {
    for (let col = 0; col < dataValidations[row].length; col++) {
      const validation = dataValidations[row][col];
      if (validation && validation.getCriteriaType() !== SpreadsheetApp.DataValidationCriteria.VALUE_IN_RANGE) {
        const cellAddress = `${String.fromCharCode(65 + col)}${row + 1}`;
        const header = headers[col] || `Kolom ${col + 1}`;
        issues.push(`Sel ${cellAddress} (${header}): ${validation.getCriteriaType()}`);
      }
    }
  }
  
  if (issues.length > 0) {
    const ui = SpreadsheetApp.getUi();
    ui.alert(
      '‚ö†Ô∏è Masalah Data Validation',
      `Ditemukan ${issues.length} masalah:\n\n${issues.join('\n')}\n\nHapus Data Validation?`,
      ui.ButtonSet.YES_NO
    );
  } else {
    SpreadsheetApp.getActiveSpreadsheet().toast('Tidak ada masalah Data Validation', 'Info', 3);
  }
}

function checkNoteCompleteness() {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Data_Murid');
    if (!sheet || sheet.getLastRow() <= 1) {
      return { total: 0, withNotes: 0, withoutNotes: 0, percentage: 0 };
    }
    
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const refColumns = ['kelas_madin_id', 'kelas_quran_id', 'kamar_id'];
    const columnIndices = {};
    
    refColumns.forEach(col => {
      const idx = headers.indexOf(col);
      if (idx !== -1) {
        columnIndices[col] = idx + 1;
      }
    });
    
    let totalCells = 0;
    let cellsWithNotes = 0;
    
    for (let row = 2; row <= sheet.getLastRow(); row++) {
      refColumns.forEach(col => {
        if (columnIndices[col]) {
          totalCells++;
          const cell = sheet.getRange(row, columnIndices[col]);
          if (cell.getNote()) {
            cellsWithNotes++;
          }
        }
      });
    }
    
    const percentage = totalCells > 0 ? Math.round((cellsWithNotes / totalCells) * 100) : 0;
    
    const result = {
      total: totalCells,
      withNotes: cellsWithNotes,
      withoutNotes: totalCells - cellsWithNotes,
      percentage: percentage
    };
    
    console.log(`üìä Note completeness: ${percentage}% (${cellsWithNotes}/${totalCells})`);
    
    const ui = SpreadsheetApp.getUi();
    ui.alert(
      'üìä Note Completeness Check',
      `Status kelengkapan notes:\n\n` +
      `‚úÖ Dengan notes: ${cellsWithNotes}\n` +
      `‚ùå Tanpa notes: ${totalCells - cellsWithNotes}\n` +
      `üìä Total sel: ${totalCells}\n` +
      `üéØ Persentase: ${percentage}%\n\n` +
      (percentage < 100 ? 
        `Gunakan "Fix Existing Notes" untuk melengkapi notes` : 
        `üéâ Semua notes sudah lengkap!`),
      ui.ButtonSet.OK
    );
    
    return result;
    
  } catch (error) {
    console.error(`‚ùå Check completeness error: ${error.toString()}`);
    return { error: error.toString() };
  }
}

function checkSyncStatus() {
  try {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheets = spreadsheet.getSheets();
    
    let status = 'üìä STATUS SINKRONISASI PPMA\n\nüìã DATA SHEETS:\n';
    sheets.forEach(sheet => {
      const sheetName = sheet.getName();
      if (!sheetName.includes('SUMMARY')) {
        const dataRange = sheet.getDataRange();
        const numRows = dataRange.getNumRows();
        const numCols = dataRange.getNumColumns();
        status += `‚Ä¢ ${sheetName}: ${numRows-1} baris, ${numCols} kolom\n`;
      }
    });
    
    status += '\nüîó KONEKSI API:\n';
    const apiTest = testAPIConnection();
    status += `‚Ä¢ API Sync: ${apiTest.includes('SUCCESS') ? '‚úÖ Berhasil' : '‚ùå Gagal'}\n`;
    
    status += '\n‚öôÔ∏è SISTEM TRIGGER:\n';
    const triggerStatus = checkEditTrigger();
    status += `‚Ä¢ Edit Trigger: ${triggerStatus ? '‚úÖ Aktif' : '‚ùå Tidak Aktif'}\n`;
    
    status += '\nüïê INFORMASI:\n';
    status += `‚Ä¢ Waktu: ${new Date().toLocaleString()}\n`;
    status += `‚Ä¢ User: ${Session.getActiveUser().getEmail()}\n`;
    
    // PERBAIKAN: Gunakan SpreadsheetApp.getUi() bukan .toast()
    const ui = SpreadsheetApp.getUi(); // <-- INI YANG BENAR
    ui.alert('Status Sinkronisasi PPMA', status, ui.ButtonSet.OK);
    
    // Tampilkan juga toast notifikasi
    spreadsheet.toast('Status sync ditampilkan di dialog', 'Info', 5);
    
    return status;
  } catch (error) {
    const errorMsg = `‚ùå Error checkSyncStatus: ${error.toString()}`;
    const ui = SpreadsheetApp.getUi();
    ui.alert('Error Status Sync', errorMsg, ui.ButtonSet.OK);
    return errorMsg;
  }
}

// =============================================
// 4. FUNGSI STRUKTUR DATABASE
// =============================================
function getDatabaseTableStructure(tableName) {
  try {
    Logger.log(`üîç Mengambil struktur tabel: ${tableName}`);
    
    const payload = {
      action: 'get_table_structure',
      table: tableName
    };
    
    const options = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      payload: JSON.stringify(payload),
      'muteHttpExceptions': true,
      'timeout': 30000
    };
    
    const response = UrlFetchApp.fetch(API_BASE_URL, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    if (responseCode === 200) {
      const result = JSON.parse(responseText);
      if (result.success && result.structure) {
        Logger.log(`‚úÖ Struktur ${tableName}: ${result.structure.length} kolom`);
        return result.structure;
      } else {
        Logger.log(`‚ùå Gagal dapat struktur: ${result.error}`);
        return null;
      }
    } else {
      Logger.log(`‚ùå HTTP Error: ${responseCode}`);
      return null;
    }
  } catch (error) {
    Logger.log(`‚ùå Error get structure: ${error.toString()}`);
    return null;
  }
}

function getDatabaseTableStructureRobust(tableName) {
  try {
    Logger.log(`üîç Mengambil struktur tabel: ${tableName} dengan robust method...`);
    
    const payload = {
      action: 'get_table_structure',
      table: tableName
    };
    
    const options = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      payload: JSON.stringify(payload),
      'muteHttpExceptions': true,
      'timeout': 15000
    };
    
    const response = UrlFetchApp.fetch(API_BASE_URL, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    Logger.log(`üìä Response Code: ${responseCode}`);
    
    if (responseCode === 200) {
      const result = JSON.parse(responseText);
      if (result.success && result.structure) {
        Logger.log(`‚úÖ Struktur ${tableName}: ${result.structure.length} kolom`);
        return result.structure;
      } else {
        Logger.log(`‚ö†Ô∏è API structure gagal: ${result.error || 'Unknown error'}`);
      }
    } else {
      Logger.log(`‚ùå HTTP Error: ${responseCode}`);
    }
  } catch (error) {
    Logger.log(`‚ùå Error get structure: ${error.toString()}`);
  }
  
  Logger.log(`üîÑ Menggunakan fallback structure untuk ${tableName}`);
  return getFallbackTableStructure(tableName);
}

function getFallbackTableStructure(tableName) {
  const fallbackStructures = {
    'murid': [
      {Field: 'murid_id'}, {Field: 'nama'}, {Field: 'nis'}, {Field: 'nik'}, 
      {Field: 'no_hp'}, {Field: 'alamat'}, {Field: 'nama_wali'}, {Field: 'no_wali'},
      {Field: 'foto'}, {Field: 'created_at'}, {Field: 'updated_at'}
    ],
    'guru': [
      {Field: 'guru_id'}, {Field: 'nama'}, {Field: 'nip'}, {Field: 'nik'},
      {Field: 'jenis_kelamin'}, {Field: 'no_hp'}, {Field: 'alamat'}, 
      {Field: 'jabatan'}, {Field: 'foto'}, {Field: 'created_at'}, {Field: 'updated_at'}
    ],
    'users': [
      {Field: 'user_id'}, {Field: 'username'}, {Field: 'password'}, 
      {Field: 'email'}, {Field: 'role'}, {Field: 'status'}, 
      {Field: 'last_login'}, {Field: 'created_at'}, {Field: 'updated_at'}
    ],
    'alumni': [
      {Field: 'alumni_id'}, {Field: 'nama'}, {Field: 'nis'}, {Field: 'nik'},
      {Field: 'no_hp'}, {Field: 'alamat'}, {Field: 'tahun_masuk'}, 
      {Field: 'tahun_keluar'}, {Field: 'status_keluar'}, {Field: 'keterangan'},
      {Field: 'pekerjaan'}, {Field: 'pendidikan_lanjut'}, {Field: 'foto'},
      {Field: 'created_at'}, {Field: 'updated_at'}
    ]
  };
  
  return fallbackStructures[tableName] || [];
}

function detectAndSyncTableStructure(sheetName) {
  try {
    const tableName = getTableName(sheetName);
    Logger.log(`üîç Mendeteksi struktur database untuk ${tableName}...`);
    
    const dbColumns = getDatabaseTableStructure(tableName);
    if (!dbColumns || dbColumns.length === 0) {
      Logger.log(`‚ö†Ô∏è Tidak bisa mendapatkan struktur database untuk ${tableName}`);
      return null;
    }
    
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    const dbColumnNames = dbColumns.map(col => col.Field || col.column_name);
    Logger.log(`üìä Kolom di database ${tableName}: ${dbColumnNames.join(', ')}`);
    Logger.log(`üìã Kolom di sheet ${sheetName}: ${headers.join(', ')}`);
    
    const invalidColumns = headers.filter(header => 
      header && !dbColumnNames.includes(header.toString().trim())
    );
    
    if (invalidColumns.length > 0) {
      Logger.log(`‚ùå Kolom tidak valid di ${sheetName}: ${invalidColumns.join(', ')}`);
    } else {
      Logger.log(`‚úÖ Semua kolom di ${sheetName} valid`);
    }
    
    return {
      validColumns: headers.filter(header => 
        header && dbColumnNames.includes(header.toString().trim())
      ),
      invalidColumns: invalidColumns,
      dbColumns: dbColumnNames
    };
  } catch (error) {
    Logger.log(`‚ùå Error deteksi struktur: ${error}`);
    return null;
  }
}

function getPrimaryKeyForTable(tableName) {
  const mapping = {
    'guru': 'guru_id',
    'murid': 'murid_id',
    'users': 'user_id',
    'alumni': 'alumni_id'
  };
  
  return mapping[tableName] || 'id';
}

function getPrimaryKeyForSheet(sheetName) {
  const pkMap = {
    'Data_Murid': 'murid_id',
    'Data_Guru': 'guru_id',
    'Data_Users': 'user_id',
    'Data_Alumni': 'alumni_id'
  };
  
  return pkMap[sheetName] || 'id';
}

function getColumnMapping(sheetName) {
  const mappings = {
    'Data_Murid': {
      sheetToDB: {
        'kelas_madin': 'kelas_madin_id',
        'kelas_quran': 'kelas_quran_id',
        'kamar': 'kamar_id'
      }
    },
    'Data_Users': {
      sheetToDB: {
        'user_id': 'id'
      }
    }
  };
  
  return mappings[sheetName] || {};
}

// =============================================
// 5. FUNGSI TESTING API
// =============================================
function testAPIConnection() {
  try {
    const url = `${API_BASE_URL}?action=test`;
    const options = {
      'muteHttpExceptions': true,
      'timeout': 30000
    };
    
    const startTime = new Date().getTime();
    const response = UrlFetchApp.fetch(url, options);
    const endTime = new Date().getTime();
    const responseTime = endTime - startTime;
    
    const responseCode = response.getResponseCode();
    const contentText = response.getContentText();
    
    if (responseCode === 200) {
      const data = JSON.parse(contentText);
      return data.success ? `SUCCESS - API working! (${responseTime}ms)` : `ERROR: ${data.error}`;
    } else {
      return `ERROR - HTTP ${responseCode}`;
    }
  } catch (error) {
    return `ERROR: ${error.toString()}`;
  }
}

function testSpecificEndpoint(endpoint) {
  try {
    const url = `${API_BASE_URL}?action=${endpoint}`;
    const options = {
      'muteHttpExceptions': true,
      'timeout': 30000
    };
    
    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();
    const contentText = response.getContentText();
    
    if (responseCode === 200) {
      const data = JSON.parse(contentText);
      return {
        success: data.success,
        dataCount: data.data ? data.data.length : 0,
        message: data.message || 'No message'
      };
    } else {
      return {
        success: false,
        error: `HTTP ${responseCode}`
      };
    }
  } catch (error) {
    return {
      success: false,
      error: error.toString()
    };
  }
}

function testStructureAPI() {
  try {
    Logger.log('üß™ TESTING STRUCTURE API...');
    
    const testTables = ['murid', 'guru', 'users', 'alumni'];
    const results = [];
    
    for (const tableName of testTables) {
      try {
        Logger.log(`üîç Testing ${tableName}...`);
        
        const payload = {
          action: 'get_table_structure',
          table: tableName
        };
        
        const options = {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          payload: JSON.stringify(payload),
          'muteHttpExceptions': true,
          'timeout': 10000
        };
        
        const startTime = new Date().getTime();
        const response = UrlFetchApp.fetch(API_BASE_URL, options);
        const endTime = new Date().getTime();
        const responseTime = endTime - startTime;
        
        const responseCode = response.getResponseCode();
        const responseText = response.getContentText();
        
        let status = '‚ùå';
        let message = '';
        
        if (responseCode === 200) {
          try {
            const result = JSON.parse(responseText);
            if (result.success) {
              status = '‚úÖ';
              message = `SUCCESS - ${result.structure?.length || 0} columns (${responseTime}ms)`;
            } else {
              message = `ERROR: ${result.error || 'Unknown'} (${responseTime}ms)`;
            }
          } catch (e) {
            message = `PARSE ERROR: ${e.toString()} (${responseTime}ms)`;
          }
        } else {
          message = `HTTP ${responseCode} (${responseTime}ms)`;
        }
        
        results.push(`${status} ${tableName}: ${message}`);
        
      } catch (error) {
        results.push(`‚ùå ${tableName}: ${error.toString()}`);
      }
      
      Utilities.sleep(1000);
    }
    
    const report = results.join('\n');
    Logger.log(`üìä STRUCTURE API TEST REPORT:\n${report}`);
    
    const ui = SpreadsheetApp.getUi();
    ui.alert('üß™ Structure API Test', report, ui.ButtonSet.OK);
    
    return results;
    
  } catch (error) {
    const errorMsg = `‚ùå Structure API test failed: ${error.toString()}`;
    Logger.log(errorMsg);
    return [errorMsg];
  }
}

function quickDiagnosis() {
  const diagnosis = [];
  
  // Test koneksi dasar
  diagnosis.push('üîó TEST KONEKSI DASAR:');
  const apiTest = testAPIConnection();
  diagnosis.push(`‚Ä¢ API Sync: ${apiTest.includes('SUCCESS') ? '‚úÖ Berhasil' : '‚ùå Gagal'}`);
  
  // Cek data di sheets
  diagnosis.push('\nüìä DATA DI SHEETS:');
  const sheets = ['Data_Guru', 'Data_Murid', 'Data_Users', 'Data_Alumni'];
  sheets.forEach(sheetName => {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    if (sheet) {
      const rowCount = sheet.getLastRow() - 1;
      diagnosis.push(`‚Ä¢ ${sheetName}: ${rowCount} baris data`);
    }
  });
  
  // Test update sederhana
  diagnosis.push('\nüß™ TEST UPDATE SEDERHANA:');
  try {
    const testData = {
      table: 'guru',
      action: 'update',
      data: { nama: 'Test Diagnostic' },
      where: { guru_id: 1 }
    };
    
    const options = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      payload: JSON.stringify(testData),
      'muteHttpExceptions': true
    };
    
    const response = UrlFetchApp.fetch(API_UPDATE_URL, options);
    diagnosis.push(`‚Ä¢ API Update: ${response.getResponseCode() === 200 ? '‚úÖ Berfungsi' : '‚ùå Bermasalah'}`);
  } catch (e) {
    diagnosis.push(`‚Ä¢ API Update: ‚ùå Error - ${e.toString()}`);
  }
  
  const result = diagnosis.join('\n');
  Logger.log('QUICK DIAGNOSIS:\n' + result);
  
  const ui = SpreadsheetApp.getUi();
  ui.alert('Quick Diagnosis', result, ui.ButtonSet.OK);
  
  return result;
}

function testPushSingleRow() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Data_Guru');
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const firstRow = data[1]; // Baris kedua (data pertama)
  
  console.log('Headers:', headers);
  console.log('First row data:', firstRow);
  
  const prepared = prepareDataForUpdateFlexible(headers, firstRow, 'Data_Guru');
  console.log('Prepared for update:', prepared);
  
  if (prepared.isValid) {
    const result = updateDataToMySQL('guru', prepared.updateData, prepared.whereCondition);
    console.log('Update result:', result);
  } else {
    console.log('Data tidak valid untuk update');
  }
}

function testPushLimited() {
  try {
    console.log('üß™ Test push 5 data pertama...');
    
    const sheet = SpreadsheetApp.getActiveSpreadsheet()
      .getSheetByName('Data_Murid');
    
    if (!sheet || sheet.getLastRow() <= 1) {
      return 'Tidak ada data di Data_Murid';
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    let successCount = 0;
    let errorCount = 0;
    
    // Proses hanya 5 baris pertama
    const limit = Math.min(5, data.length - 1);
    
    for (let i = 1; i <= limit; i++) {
      const rowData = data[i];
      
      // Siapkan data sederhana
      const updateData = {};
      const whereCondition = {};
      
      // Cari murid_id
      const muridIdIndex = headers.indexOf('murid_id');
      if (muridIdIndex !== -1 && rowData[muridIdIndex]) {
        whereCondition['murid_id'] = rowData[muridIdIndex];
        
        // Update hanya nama dan no_hp
        const namaIndex = headers.indexOf('nama');
        const noHpIndex = headers.indexOf('no_hp');
        
        if (namaIndex !== -1 && rowData[namaIndex]) {
          updateData['nama'] = rowData[namaIndex];
        }
        
        if (noHpIndex !== -1 && rowData[noHpIndex]) {
          updateData['no_hp'] = rowData[noHpIndex];
        }
        
        try {
          const result = updateDataToMySQL('murid', updateData, whereCondition);
          
          if (result && result.success) {
            successCount++;
          } else {
            errorCount++;
          }
        } catch (error) {
          errorCount++;
        }
      }
      
      Utilities.sleep(1000); // Delay 1 detik
    }
    
    const message = `Test push: ${successCount}‚úÖ ${errorCount}‚ùå`;
    console.log(`‚ö° ${message}`);
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      message,
      'Test Push',
      5
    );
    
    return message;
    
  } catch (error) {
    console.error(`‚ùå Test push gagal: ${error.toString()}`);
    return `Error: ${error.toString()}`;
  }
}

function testDataMuridPush() {
  try {
    Logger.log('üß™ TESTING OPTIMIZED PUSH DENGAN DATA_MURID...');
    
    const sheetName = 'Data_Murid';
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    
    if (!sheet) {
      throw new Error('Sheet Data_Murid tidak ditemukan');
    }
    
    const data = sheet.getDataRange().getValues();
    const totalRows = data.length - 1;
    
    Logger.log(`üìä Data_Murid: ${totalRows} baris data ditemukan`);
    
    if (totalRows === 0) {
      Logger.log('‚ö†Ô∏è Tidak ada data di Data_Murid untuk testing');
      return { success: false, error: 'Tidak ada data' };
    }
    
    // Test dengan approach optimized
    const result = pushSheetDataOptimized(sheetName);
    
    const testResult = {
      sheet: sheetName,
      totalRows: totalRows,
      successCount: result.successCount || 0,
      errorCount: result.errorCount || 0,
      skippedCount: result.skippedCount || 0,
      successRate: result.totalProcessed > 0 ? 
        Math.round((result.successCount / result.totalProcessed) * 100) : 0,
      approach: 'optimized'
    };
    
    Logger.log(`üìà HASIL TEST DATA_MURID: ${testResult.successRate}% sukses`);
    
    // Tampilkan hasil di dialog
    const ui = SpreadsheetApp.getUi();
    ui.alert(
      'üß™ TEST DATA_MURID - OPTIMIZED PUSH',
      `Hasil Testing Data_Murid:\n\n` +
      `üìä Total Data: ${totalRows} baris\n` +
      `‚úÖ Berhasil: ${testResult.successCount}\n` +
      `‚ùå Error: ${testResult.errorCount}\n` +
      `‚è© Skipped: ${testResult.skippedCount}\n` +
      `üìà Success Rate: ${testResult.successRate}%\n\n` +
      `Status: ${testResult.successRate === 100 ? 'üéâ SEMPURNA' : testResult.successRate >= 90 ? 'üëç BAIK' : '‚ö†Ô∏è PERLU PERBAIKAN'}`,
      ui.ButtonSet.OK
    );
    
    return testResult;
    
  } catch (error) {
    const errorMsg = `‚ùå Test Data_Murid gagal: ${error.toString()}`;
    Logger.log(errorMsg);
    
    const ui = SpreadsheetApp.getUi();
    ui.alert('Test Gagal', errorMsg, ui.ButtonSet.OK);
    
    return { success: false, error: errorMsg };
  }
}

// =============================================
// 6. FUNGSI SINKRONISASI (API ‚Üí SHEET)
// =============================================
function syncDataWithRetry(syncFunction, name, maxRetries = 3) {
  let retryCount = 0;
  
  while (retryCount <= maxRetries) {
    try {
      const result = syncFunction();
      return result;
    } catch (error) {
      retryCount++;
      if (retryCount > maxRetries) {
        return `ERROR: Gagal sinkron ${name} - ${error.toString()}`;
      }
      const delay = Math.pow(2, retryCount) * 1000;
      Utilities.sleep(delay);
    }
  }
}

function syncDataUmumViaAPI(endpoint, sheetName, color) {
  try {
    console.log(`üîÑ Sync ${sheetName} via API...`);
    
    const url = `${API_BASE_URL}?action=${endpoint}&limit=10000`;
    const options = {
      'muteHttpExceptions': true,
      'timeout': 60000
    };
    
    const response = UrlFetchApp.fetch(url, options);
    const result = JSON.parse(response.getContentText());
    
    if (result.success) {
      const data = result.data || [];
      
      if (data.length === 0) {
        return `SUCCESS: 0 data ${sheetName} (tidak ada data)`;
      }
      
      // Gunakan metode AMAN: buat sheet sementara
      const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
      const tempSheetName = `${sheetName}_TEMP_${new Date().getTime()}`;
      const tempSheet = spreadsheet.insertSheet(tempSheetName);
      
      const headers = Object.keys(data[0]);
      
      // Header
      const headerRange = tempSheet.getRange(1, 1, 1, headers.length);
      headerRange.setValues([headers])
                .setFontWeight("bold")
                .setBackground(color)
                .setFontColor('white');
      
      // Data
      const rows = data.map(row => headers.map(header => {
        let value = row[header] || '';
        if (isLongNumericField(header, value)) {
          value = formatForSheetDisplay(value);
        }
        return value;
      }));
      
      if (rows.length > 0) {
        tempSheet.getRange(2, 1, rows.length, headers.length).setValues(rows);
      }
      
      setColumnFormats(tempSheet, headers);
      
      // Ganti sheet lama jika ada
      const oldSheet = spreadsheet.getSheetByName(sheetName);
      if (oldSheet) {
        spreadsheet.deleteSheet(oldSheet);
      }
      
      tempSheet.setName(sheetName);
      
      // Auto resize
      for (let col = 1; col <= headers.length; col++) {
        tempSheet.autoResizeColumn(col);
      }
      
      return `SUCCESS: ${data.length} data ${sheetName} disinkronkan`;
    } else {
      throw new Error(result.error || 'Unknown error from API');
    }
  } catch (error) {
    return `ERROR: Gagal sinkron ${sheetName} - ${error.toString()}`;
  }
}

function syncDataManualDenganDebug() {
  try {
    Logger.log('üîß Sync Data Manual dengan Debug...');
    
    const results = [];
    
    // Test setiap endpoint satu per satu dengan debug
    const endpoints = [
      { name: 'Murid', endpoint: 'get_murid', sheet: 'Data_Murid' },
      { name: 'Guru', endpoint: 'get_guru', sheet: 'Data_Guru' },
      { name: 'Users', endpoint: 'get_users', sheet: 'Data_Users' },
      { name: 'Alumni', endpoint: 'get_alumni', sheet: 'Data_Alumni' }
    ];
    
    for (const item of endpoints) {
      try {
        Logger.log(`üîç Testing ${item.name} API...`);
        
        const url = `${API_BASE_URL}?action=${item.endpoint}`;
        const options = {
          'muteHttpExceptions': true,
          'timeout': 30000
        };
        
        const response = UrlFetchApp.fetch(url, options);
        const responseCode = response.getResponseCode();
        const responseText = response.getContentText();
        
        Logger.log(`üìä ${item.name} Response: ${responseCode}`);
        
        if (responseCode === 200) {
          const result = JSON.parse(responseText);
          
          if (result.success && result.data && result.data.length > 0) {
            Logger.log(`‚úÖ ${item.name}: ${result.data.length} data ditemukan`);
            
            // Isi data ke sheet
            const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(item.sheet);
            if (sheet) {
              const headers = Object.keys(result.data[0]);
              
              // Set header jika belum sesuai
              const currentHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
              if (JSON.stringify(currentHeaders) !== JSON.stringify(headers)) {
                sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
              }
              
              // Clear existing data
              if (sheet.getLastRow() > 1) {
                sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
              }
              
              // Isi data baru
              const rows = result.data.map(row => 
                headers.map(header => row[header] || '')
              );
              
              if (rows.length > 0) {
                sheet.getRange(2, 1, rows.length, headers.length).setValues(rows);
                results.push(`SUCCESS: ${item.name} - ${rows.length} data disinkronkan`);
              }
            }
          } else {
            results.push(`INFO: ${item.name} - ${result.error || 'Tidak ada data'}`);
          }
        } else {
          results.push(`ERROR: ${item.name} - HTTP ${responseCode}`);
        }
        
      } catch (error) {
        results.push(`ERROR: ${item.name} - ${error.toString()}`);
      }
      
      Utilities.sleep(2000); // Delay antar request
    }
    
    // Tampilkan hasil
    const sheet = buatSummarySheet();
    sheet.clear();
    sheet.getRange(1, 1).setValue('üîß HASIL SYNC DATA MANUAL').setFontWeight("bold");
    
    let row = 3;
    results.forEach(result => {
      sheet.getRange(row, 1).setValue(`‚Ä¢ ${result}`);
      row++;
    });
    
    const successCount = results.filter(r => r.includes('SUCCESS')).length;
    const message = `Sync Data Manual: ${successCount}/${endpoints.length} berhasil`;
    
    SpreadsheetApp.getActiveSpreadsheet().toast(message, 'Sync Manual', 8);
    Logger.log(`‚úÖ ${message}`);
    
    return { success: true, results };
    
  } catch (error) {
    const errorMsg = `‚ùå Sync manual gagal: ${error.toString()}`;
    Logger.log(errorMsg);
    SpreadsheetApp.getActiveSpreadsheet().toast(errorMsg, 'Error', 10);
    return { success: false, error: errorMsg };
  }
}

function syncDataMuridWithID() {
  try {
    const url = `${API_BASE_URL}?action=get_murid`;
    const options = { 'muteHttpExceptions': true, 'timeout': 60000 };
    
    const response = UrlFetchApp.fetch(url, options);
    const result = JSON.parse(response.getContentText());
    
    if (result.success) {
      const data = result.data || [];
      const sheet = buatSheet('Data_Murid');
      
      // HEADER YANG SESUAI DENGAN DATABASE
      const headers = [
        'murid_id', 'nama', 'nis', 'nik', 
        'no_hp', 'alamat', 'nama_wali', 'no_wali', 
        'nilai', 'foto', 'kelas_madin_id', 'kelas_quran_id', 
        'kamar_id', 'created_at', 'updated_at'
      ];
      
      // Header
      const headerRange = sheet.getRange(1, 1, 1, headers.length);
      headerRange.setValues([headers])
                .setFontWeight("bold")
                .setBackground('#4CAF50')
                .setFontColor('white');
      
      // Data - Mapping langsung tanpa transformasi
      const rows = data.map(item => headers.map(header => 
        item[header] !== undefined && item[header] !== null ? item[header] : ''
      ));
      
      if (rows.length > 0) {
        sheet.getRange(2, 1, rows.length, headers.length).setValues(rows);
      }
      
      // Set format untuk kolom ID dan numeric
      headers.forEach((header, index) => {
        const colNumber = index + 1;
        const cleanHeader = header.toLowerCase();
        
        if (cleanHeader.includes('_id') || cleanHeader.includes('nik') || 
            cleanHeader.includes('nis') || cleanHeader.includes('no_')) {
          if (sheet.getLastRow() > 1) {
            sheet.getRange(2, colNumber, sheet.getLastRow() - 1, 1).setNumberFormat('@');
          }
        }
      });
      
      // Auto resize
      for (let col = 1; col <= headers.length; col++) {
        sheet.autoResizeColumn(col);
      }
      
      return `SUCCESS: ${data.length} data murid disinkronkan`;
    } else {
      throw new Error(result.error || 'Unknown error from API');
    }
  } catch (error) {
    return `ERROR: Gagal sinkron data murid - ${error.toString()}`;
  }
}

function syncDataMuridWithNotes() {
  try {
    const url = `${API_BASE_URL}?action=get_murid`;
    const options = { 'muteHttpExceptions': true, 'timeout': 30000 };
    
    const response = UrlFetchApp.fetch(url, options);
    const result = JSON.parse(response.getContentText());
    
    if (result.success) {
      const data = result.data || [];
      const sheet = buatSheet('Data_Murid');
      const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
      
      sheet.getDataRange().clearDataValidations();
      
      const headers = [
        'murid_id', 'nama', 'nis', 'nik', 
        'no_hp', 'alamat', 'nama_wali', 'no_wali', 
        'nilai', 'foto', 'kelas_madin_id', 'kelas_quran_id', 
        'kamar_id', 'created_at', 'updated_at'
      ];
      
      const headerRange = sheet.getRange(1, 1, 1, headers.length);
      headerRange.setValues([headers])
                .setFontWeight("bold")
                .setBackground('#4CAF50')
                .setFontColor('white');
      
      const rows = data.map(item => headers.map(header => 
        item[header] !== undefined && item[header] !== null ? item[header] : ''
      ));
      
      if (rows.length > 0) {
        sheet.getRange(2, 1, rows.length, headers.length).setValues(rows);
      }
      
      const refMapping = {
        'kelas_madin_id': 'Ref_KelasMadin',
        'kelas_quran_id': 'Ref_KelasQuran',
        'kamar_id': 'Ref_Kamar'
      };
      
      const mapping = {};
      Object.keys(refMapping).forEach(key => {
        const refSheet = spreadsheet.getSheetByName(refMapping[key]);
        if (refSheet) {
          const refData = refSheet.getDataRange().getValues();
          mapping[key] = {};
          for (let i = 1; i < refData.length; i++) {
            const id = refData[i][0];
            const nama = refData[i][1];
            if (id && nama) {
              mapping[key][id] = nama;
            }
          }
        }
      });
      
      const lastRow = sheet.getLastRow();
      for (let i = 2; i <= lastRow; i++) {
        Object.keys(refMapping).forEach(key => {
          const colIndex = headers.indexOf(key) + 1;
          const cell = sheet.getRange(i, colIndex);
          const id = cell.getValue();
          
          if (id && mapping[key] && mapping[key][id]) {
            cell.setNote(mapping[key][id]);
          }
        });
      }
      
      headers.forEach((header, index) => {
        const colNumber = index + 1;
        const cleanHeader = header.toLowerCase();
        
        if (cleanHeader.includes('nik') || cleanHeader.includes('nis') || 
            cleanHeader.includes('nip') || cleanHeader === 'no_hp') {
          if (sheet.getLastRow() > 1) {
            sheet.getRange(2, colNumber, sheet.getLastRow() - 1, 1).setNumberFormat('@');
          }
        }
      });
      
      for (let col = 1; col <= headers.length; col++) {
        sheet.autoResizeColumn(col);
      }
      
      return `SUCCESS: ${data.length} data murid disinkronkan dengan note`;
    } else {
      throw new Error(result.error || 'Unknown error from API');
    }
  } catch (error) {
    return `ERROR: Gagal sinkron data murid - ${error.toString()}`;
  }
}

function syncDataMuridWithNotesEnhanced() {
  try {
    console.log('üöÄ Memulai sync data murid dengan notes enhanced...');
    
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const startTime = new Date().getTime();
    
    syncReferensiData();
    Utilities.sleep(3000);
    
    const url = `${API_BASE_URL}?action=get_murid`;
    const options = { 'muteHttpExceptions': true, 'timeout': 30000 };
    
    const response = UrlFetchApp.fetch(url, options);
    const result = JSON.parse(response.getContentText());
    
    if (!result.success) {
      throw new Error(result.error || 'API error');
    }
    
    const data = result.data || [];
    console.log(`üìä ${data.length} data murid ditemukan`);
    
    if (data.length === 0) {
      return 'Tidak ada data murid';
    }
    
    const sheet = buatSheet('Data_Murid');
    sheet.clearDataValidations();
    
    const headers = [
      'murid_id', 'nama', 'nis', 'nik', 
      'no_hp', 'alamat', 'nama_wali', 'no_wali', 
      'nilai', 'foto', 'kelas_madin_id', 'kelas_quran_id', 
      'kamar_id', 'created_at', 'updated_at'
    ];
    
    sheet.getRange(1, 1, 1, headers.length)
      .setValues([headers])
      .setFontWeight('bold')
      .setBackground('#4CAF50')
      .setFontColor('white');
    
    const rows = data.map(item => 
      headers.map(header => item[header] !== undefined && item[header] !== null ? item[header] : '')
    );
    
    if (rows.length > 0) {
      sheet.getRange(2, 1, rows.length, headers.length).setValues(rows);
    }
    
    console.log('üó∫Ô∏è Membuat mapping referensi...');
    const refData = getReferensiData();
    
    console.log('üìù Mengisi notes secara batch...');
    fillNotesInBatch(sheet, headers, refData);
    
    setColumnFormats(sheet, headers);
    
    for (let col = 1; col <= headers.length; col++) {
      sheet.autoResizeColumn(col);
    }
    
    setupSimpleDataValidation(sheet, headers, refData);
    
    const endTime = new Date().getTime();
    const duration = Math.round((endTime - startTime) / 1000);
    
    console.log(`‚úÖ Sync selesai dalam ${duration} detik`);
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `‚úÖ Sync berhasil: ${data.length} data murid dengan notes`,
      'Sync Enhanced',
      5
    );
    
    return `SUCCESS: ${data.length} data murid disinkronkan dengan notes`;
    
  } catch (error) {
    console.error(`‚ùå Error sync enhanced: ${error.toString()}`);
    return `ERROR: ${error.toString()}`;
  }
}

function syncDataMuridWithNotesEnhancedAman() {
  try {
    console.log('üöÄ Sync data murid dengan notes (aman)...');
    
    // 1. Ambil data dari API
    const url = `${API_BASE_URL}?action=get_murid`;
    const options = { 
      'muteHttpExceptions': true, 
      'timeout': 30000 
    };
    
    const response = UrlFetchApp.fetch(url, options);
    const result = JSON.parse(response.getContentText());
    
    if (!result.success) {
      throw new Error(result.error || 'API error');
    }
    
    const data = result.data || [];
    console.log(`üìä ${data.length} data murid ditemukan`);
    
    if (data.length === 0) {
      return 'Tidak ada data murid';
    }
    
    // 2. Buat sheet baru sementara
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const tempSheetName = 'Data_Murid_TEMP_' + new Date().getTime();
    const tempSheet = spreadsheet.insertSheet(tempSheetName);
    
    // 3. Set header yang benar
    const headers = [
      'murid_id', 'nama', 'nis', 'nik', 
      'no_hp', 'alamat', 'nama_wali', 'no_wali', 
      'nilai', 'foto', 'kelas_madin_id', 'kelas_quran_id', 
      'kamar_id', 'created_at', 'updated_at'
    ];
    
    tempSheet.getRange(1, 1, 1, headers.length)
      .setValues([headers])
      .setFontWeight('bold')
      .setBackground('#4CAF50')
      .setFontColor('white');
    
    // 4. Isi data
    const rows = data.map(item => 
      headers.map(header => item[header] !== undefined && item[header] !== null ? item[header] : '')
    );
    
    if (rows.length > 0) {
      tempSheet.getRange(2, 1, rows.length, headers.length).setValues(rows);
    }
    
    // 5. Dapatkan data referensi SEGAR
    syncReferensiData();
    Utilities.sleep(3000);
    
    const refData = getReferensiData();
    console.log('üìä Data referensi loaded:', {
      kelas_madin: Object.keys(refData.kelas_madin_id || {}).length,
      kelas_quran: Object.keys(refData.kelas_quran_id || {}).length,
      kamar: Object.keys(refData.kamar_id || {}).length
    });
    
    // 6. Tambahkan notes
    const notesResult = fillNotesInBatchEnhanced(tempSheet, headers, refData);
    console.log(`üìù Notes result: ${notesResult.notesAdded} added`);
    
    // 7. Format kolom
    setColumnFormats(tempSheet, headers);
    
    // 8. Ganti sheet lama dengan yang baru
    const oldSheet = spreadsheet.getSheetByName('Data_Murid');
    if (oldSheet) {
      spreadsheet.deleteSheet(oldSheet);
    }
    
    tempSheet.setName('Data_Murid');
    
    // 9. Auto resize
    for (let col = 1; col <= headers.length; col++) {
      tempSheet.autoResizeColumn(col);
    }
    
    // 10. Setup data validation sederhana
    setupSimpleDataValidation(tempSheet, headers, refData);
    
    const successMsg = `SUCCESS: ${data.length} data murid dengan ${notesResult.notesAdded} notes`;
    console.log(`‚úÖ ${successMsg}`);
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `‚úÖ Sync berhasil: ${data.length} data`,
      'Sync Aman',
      5
    );
    
    return successMsg;
    
  } catch (error) {
    console.error(`‚ùå Sync murid gagal: ${error.toString()}`);
    return `ERROR: ${error.toString()}`;
  }
}

function syncDataMuridDenganBackupAman() {
  try {
    console.log('üîÑ Memulai sync dengan backup (aman)...');
    
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    spreadsheet.toast('Sync dengan backup aman dimulai...', 'Info', 3);
    
    // 1. Backup terlebih dahulu
    const backupResult = backupDataMuridEfisien();
    
    if (backupResult.success) {
      console.log(`‚úÖ Backup dibuat: ${backupResult.dataCount} data`);
    } else {
      console.log('‚ö†Ô∏è Backup gagal, lanjut sync tanpa backup');
    }
    
    // 2. Jalankan sync aman
    const syncResult = syncDataMuridWithNotesEnhancedAman();
    
    // 3. Tampilkan hasil
    const summary = `üìä HASIL SYNC DENGAN BACKUP:\n\n` +
                   `‚Ä¢ Backup: ${backupResult.success ? '‚úÖ' : '‚ùå'}\n` +
                   `‚Ä¢ Sync: ${syncResult.includes('SUCCESS') ? '‚úÖ' : '‚ùå'}\n\n` +
                   `üïê ${new Date().toLocaleString()}`;
    
    console.log(summary);
    
    // Tampilkan di sheet SUMMARY
    const sheet = buatSummarySheet();
    sheet.clear();
    
    let row = 1;
    sheet.getRange(row, 1).setValue('üîÑ HASIL SYNC DENGAN BACKUP').setFontWeight("bold").setFontSize(16);
    row += 2;
    
    sheet.getRange(row, 1).setValue(`‚úÖ Backup: ${backupResult.success ? 'Berhasil' : 'Gagal'}`);
    row++;
    sheet.getRange(row, 1).setValue(`üìä Data: ${backupResult.dataCount || 0} data`);
    row++;
    sheet.getRange(row, 1).setValue(`üìÖ Timestamp: ${backupResult.timestamp || '-'}`);
    row += 2;
    
    sheet.getRange(row, 1).setValue(`üîÑ Sync: ${syncResult}`);
    row += 2;
    
    sheet.getRange(row, 1).setValue(`üéØ Status: ${syncResult.includes('SUCCESS') ? 'Berhasil' : 'Perlu periksa'}`);
    row++;
    sheet.getRange(row, 1).setValue(`üïê Waktu: ${new Date().toLocaleString()}`);
    
    sheet.autoResizeColumn(1);
    
    // Toast notification
    spreadsheet.toast(
      `Sync dengan backup selesai!`,
      '‚úÖ Sync Aman',
      5
    );
    
    return {
      backup: backupResult,
      sync: syncResult
    };
    
  } catch (error) {
    const errorMsg = `‚ùå Sync dengan backup gagal: ${error.toString()}`;
    console.error(errorMsg);
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Sync dengan backup gagal! Lihat log untuk detail.',
      'Error',
      5
    );
    
    return { success: false, error: errorMsg };
  }
}

function jalankanSyncLengkapAman() {
  try {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    
    // 1. CLEANUP backup lama terlebih dahulu (maksimal simpan 3 backup)
    const maxBackups = parseInt(PropertiesService.getScriptProperties().getProperty('MAX_BACKUPS') || '3');
    const cleanupResult = cleanupOldBackupSheets(maxBackups);
    console.log(`üßπ Cleanup: ${cleanupResult.deleted || 0} backup lama dihapus`);
    
    // 2. BUAT backup baru
    const timestamp = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyyMMdd_HHmmss');
    const backupSheetName = `BACKUP_SEBELUM_SYNC_${timestamp}`;
    const backupSheet = spreadsheet.insertSheet(backupSheetName);
    
    // Salin data murid ke backup
    const muridSheet = spreadsheet.getSheetByName('Data_Murid');
    if (muridSheet) {
      muridSheet.getDataRange().copyTo(backupSheet.getRange(1, 1));
      console.log(`‚úÖ Backup dibuat: ${backupSheetName}`);
    }
    
    // 3. SYNC REFERENSI DULU
    console.log('üîÑ Syncing referensi data...');
    spreadsheet.toast('Sync referensi data...', 'Progress', 2);
    const refResults = syncReferensiData();
    results.push('Referensi: ‚úÖ Selesai');
    console.log('‚úÖ Referensi data selesai');
    
    Utilities.sleep(2000);
    
    // 4. SYNC DATA MURID DENGAN NOTES (VERSI AMAN)
    console.log('üîÑ Syncing data murid...');
    spreadsheet.toast('Sync data murid...', 'Progress', 2);
    const muridResult = syncDataMuridWithNotesEnhancedAman();
    results.push(`Murid: ${muridResult}`);
    console.log(`‚úÖ Data murid: ${muridResult}`);
    
    Utilities.sleep(2000);
    
    // 5. SYNC DATA LAINNYA TANPA MENGANGGU
    const syncTasks = [
      { name: 'Guru', func: syncDataGuruViaAPI },
      { name: 'Users', func: syncDataUsersViaAPI },
      { name: 'Alumni', func: syncDataAlumniViaAPI }
    ];
    
    for (const task of syncTasks) {
      try {
        console.log(`üîÑ Syncing ${task.name}...`);
        spreadsheet.toast(`Sync ${task.name}...`, 'Progress', 2);
        
        const result = task.func();
        results.push(`${task.name}: ${result.includes('SUCCESS') ? '‚úÖ' : '‚ùå'}`);
        
        console.log(`‚úÖ ${task.name}: ${result}`);
        Utilities.sleep(1500);
      } catch (error) {
        results.push(`${task.name}: ‚ùå Error`);
        console.error(`‚ùå ${task.name} error: ${error}`);
      }
    }
    
    // 6. SETUP TRIGGER JIKA PERLU
    if (!checkEditTrigger()) {
      setupSimpleEditTrigger();
      results.push('Trigger: ‚úÖ Diaktifkan');
      console.log('‚úÖ Edit trigger diaktifkan');
    }
    
    // 7. TAMPILKAN HASIL
    const summary = `üìä HASIL SYNCRONISASI LENGKAP:\n\n` +
                   results.map(r => `‚Ä¢ ${r}`).join('\n') + 
                   `\n\n‚úÖ Backup dibuat di sheet: ${backupSheetName}` +
                   `\n\nüïê ${new Date().toLocaleString()}`;
    
    console.log(summary);
    
    const ui = SpreadsheetApp.getUi();
    ui.alert('‚úÖ Sinkronisasi Lengkap Selesai', summary, ui.ButtonSet.OK);
    
    return { 
      success: true, 
      backup: backupSheetName,
      cleanup: cleanupResult,
      results 
    };
    
  } catch (error) {
    const errorMsg = `‚ùå Sync gagal: ${error.toString()}`;
    console.error(errorMsg);
    return { success: false, error: errorMsg };
  }
}

function syncDataMuridViaAPI() {
  return syncDataUmumViaAPI('get_murid', 'Data_Murid', '#4CAF50');
}

function syncDataGuruViaAPI() {
  return syncDataUmumViaAPI('get_guru', 'Data_Guru', '#2196F3');
}

function syncDataAbsensiViaAPI() {
  return syncDataUmumViaAPI('get_absensi', 'Data_Absensi', '#FF9800');
}

function syncDataPelanggaranViaAPI() {
  return syncDataUmumViaAPI('get_pelanggaran', 'Data_Pelanggaran', '#F44336');
}

function syncDataPerizinanViaAPI() {
  return syncDataUmumViaAPI('get_perizinan', 'Data_Perizinan', '#9C27B0');
}

function syncDataAlumniViaAPI() {
  return syncDataUmumViaAPI('get_alumni', 'Data_Alumni', '#607D8B');
}

function syncDataUsersViaAPI() {
  return syncDataUmumViaAPI('get_users', 'Data_Users', '#FF5722');
}

function syncReferensiData() {
  const results = [];
  
  const refEndpoints = [
    { name: 'Ref_KelasMadin', endpoint: 'get_ref_kelas_madin', color: '#4CAF50' },
    { name: 'Ref_Kamar', endpoint: 'get_ref_kamar', color: '#2196F3' },
    { name: 'Ref_KelasQuran', endpoint: 'get_ref_kelas_quran', color: '#9C27B0' }
  ];
  
  refEndpoints.forEach(item => {
    try {
      const url = `${API_BASE_URL}?action=${item.endpoint}`;
      const options = { 'muteHttpExceptions': true, 'timeout': 30000 };
      
      const response = UrlFetchApp.fetch(url, options);
      const result = JSON.parse(response.getContentText());
      
      if (result.success && result.data) {
        const sheet = buatSheet(item.name);
        
        const headers = ['ID', 'Nama'];
        sheet.getRange(1, 1, 1, 2).setValues([headers])
             .setFontWeight("bold")
             .setBackground(item.color)
             .setFontColor('white');
        
        const rows = result.data.map(row => [
          row.kelas_id || row.kamar_id || row.id,
          row.nama_kelas || row.nama_kamar
        ]);
        
        if (rows.length > 0) {
          sheet.getRange(2, 1, rows.length, 2).setValues(rows);
        }
        
        sheet.getRange(2, 1, sheet.getLastRow(), 1).setNumberFormat('@');
        
        sheet.autoResizeColumn(1);
        sheet.autoResizeColumn(2);
        
        results.push(`SUCCESS: ${rows.length} data ${item.name} disinkronkan`);
      } else {
        results.push(`ERROR: Gagal ambil data ${item.name}`);
      }
    } catch (error) {
      results.push(`ERROR: ${item.name} - ${error.toString()}`);
    }
  });
  
  return results;
}

function syncDataJadwalMadinAman() {
  return syncDataUmumViaAPI('get_jadwal_madin', 'Data_Jadwal_Madin', '#3F51B5');
}

function syncDataJadwalQuranAman() {
  return syncDataUmumViaAPI('get_jadwal_quran', 'Data_Jadwal_Quran', '#9C27B0');
}

function syncDataJadwalKegiatanAman() {
  return syncDataUmumViaAPI('get_jadwal_kegiatan', 'Data_Jadwal_Kegiatan', '#FF9800');
}

function syncDataStabil() {
  return syncSemuaDataViaAPI();
}

// =============================================
// 7. FUNGSI PUSH DATA (SHEET ‚Üí API)
// =============================================
function updateDataToMySQL(table, data, where) {
  try {
    if (!table || typeof table !== 'string' || table.trim() === '') {
      throw new Error('Nama tabel tidak valid atau kosong');
    }
    
    if (!data || typeof data !== 'object' || Object.keys(data).length === 0) {
      throw new Error('Data tidak valid atau kosong');
    }
    
    if (!where || typeof where !== 'object' || Object.keys(where).length === 0) {
      throw new Error('Kondisi where tidak valid atau kosong');
    }

    const cleanData = {};
    Object.keys(data).forEach(key => {
      const value = data[key];
      
      if (value === undefined || value === null) {
        return;
      }
      
      if (typeof value === 'string' && value.trim() === '') {
        cleanData[key] = null;
      } else {
        cleanData[key] = value;
      }
    });
    
    if (Object.keys(cleanData).length === 0) {
      throw new Error('Tidak ada data yang valid untuk diupdate');
    }
    
    const payload = {
      table: table,
      action: 'update',
      data: cleanData,
      where: where
    };
    
    Logger.log(`üì§ Update ke ${table}: ${JSON.stringify(payload).substring(0, 200)}...`);
    
    const options = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      payload: JSON.stringify(payload),
      'muteHttpExceptions': true,
      'timeout': 30000,
      'followRedirects': true
    };
    
    const response = UrlFetchApp.fetch(API_UPDATE_URL, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    Logger.log(`üìä Response Code: ${responseCode}`);
    
    if (responseCode !== 200) {
      throw new Error(`HTTP ${responseCode}: ${responseText.substring(0, 200)}`);
    }
    
    if (responseText.trim() === '' || 
        responseText.includes('<!DOCTYPE') || 
        responseText.includes('<html')) {
      throw new Error('Server returned non-JSON response');
    }
    
    const result = JSON.parse(responseText);
    
    if (result.success) {
      Logger.log(`‚úÖ Berhasil update ${table}: ${result.affected_rows || 1} baris`);
      return result;
    } else {
      const errorMsg = result.error || 'Unknown error from API';
      
      if (errorMsg.includes('Duplicate entry')) {
        Logger.log(`‚ö†Ô∏è Duplicate entry: ${errorMsg}`);
        return { success: false, error: errorMsg, duplicate: true };
      } else if (errorMsg.includes('Data too long')) {
        Logger.log(`‚ö†Ô∏è Data too long: ${errorMsg}`);
        return { success: false, error: errorMsg, dataTooLong: true };
      } else if (errorMsg.includes('doesn\'t exist')) {
        Logger.log(`‚ö†Ô∏è Column doesn't exist: ${errorMsg}`);
        return { success: false, error: errorMsg, invalidColumn: true };
      } else {
        throw new Error(errorMsg);
      }
    }
  } catch (error) {
    Logger.log(`‚ùå Gagal update ke ${table}: ${error.toString()}`);
    throw error;
  }
}

function updateDataToMySQLBatch(table, dataArray) {
  try {
    Logger.log(`üîÑ Batch updating ${dataArray.length} records to ${table}`);
    
    const payload = {
      table: table,
      action: 'batch_update',
      data: dataArray
    };
    
    const options = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      payload: JSON.stringify(payload),
      'muteHttpExceptions': true,
      'timeout': 45000
    };
    
    const response = UrlFetchApp.fetch(API_UPDATE_URL, options);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    if (responseCode !== 200) {
      throw new Error(`HTTP ${responseCode}: ${responseText.substring(0, 200)}`);
    }
    
    // Handle HTML response
    if (responseText.includes('<br />') || responseText.includes('<b>') || responseText.startsWith('<!DOCTYPE')) {
      throw new Error(`Server returned HTML: ${responseText.substring(0, 300)}`);
    }
    
    const result = JSON.parse(responseText);
    
    if (result.success) {
      Logger.log(`‚úÖ Batch update successful: ${result.affected_rows || dataArray.length} records`);
      return result;
    } else {
      throw new Error(result.error || 'Batch update failed');
    }
    
  } catch (error) {
    Logger.log(`‚ùå Batch update failed: ${error.toString()}`);
    throw error;
  }
}

function prepareDataForUpdateValidated(headers, rowData, sheetName) {
  const updateData = {};
  const whereCondition = {};
  let primaryKeyFound = false;

  try {
    // Dapatkan struktur tabel dari database
    const tableName = getTableName(sheetName);
    const dbStructure = getDatabaseTableStructure(tableName);
    
    if (!dbStructure) {
      Logger.log(`‚ö†Ô∏è Tidak bisa mendapatkan struktur untuk ${tableName}, gunakan fallback`);
      return prepareDataForUpdateUniversal(headers, rowData, sheetName);
    }

    const dbColumns = dbStructure.map(col => col.Field || col.column_name);
    Logger.log(`‚úÖ Kolom valid di ${tableName}: ${dbColumns.join(', ')}`);

    headers.forEach((header, index) => {
      if (!header || header.toString().trim() === '') return;

      const headerName = header.toString().trim();
      let value = rowData[index];

      // Handle empty values
      if (value === '' || value === undefined || value === null) {
        value = null;
      }

      // Hanya proses kolom yang ada di database
      if (!dbColumns.includes(headerName)) {
        Logger.log(`‚è© Skip kolom ${headerName} - tidak ada di database`);
        return;
      }

      const cleanHeader = headerName.toLowerCase();

      // Identifikasi primary key
      if ((cleanHeader === 'id' || cleanHeader.includes('_id')) && value) {
        whereCondition[headerName] = value;
        primaryKeyFound = true;
      } 
      // Field data untuk update
      else if (!['created_at', 'updated_at', 'timestamp'].includes(cleanHeader)) {
        updateData[headerName] = value;
      }
    });

    // Fallback jika tidak ada primary key
    if (!primaryKeyFound) {
      const uniqueFields = ['email', 'nis', 'nik', 'nama', 'no_hp'];
      for (let i = 0; i < headers.length; i++) {
        const header = headers[i].toString().trim();
        const cleanHeader = header.toLowerCase();
        if (uniqueFields.includes(cleanHeader) && rowData[i] && dbColumns.includes(header)) {
          whereCondition[header] = rowData[i];
          primaryKeyFound = true;
          break;
        }
      }
    }

    Logger.log(`üîß Validated data for ${sheetName}:`);
    Logger.log(`   Where: ${JSON.stringify(whereCondition)}`);
    Logger.log(`   Update: ${JSON.stringify(updateData)}`);

    return {
      updateData: updateData,
      whereCondition: whereCondition,
      isValid: primaryKeyFound && Object.keys(updateData).length > 0,
      error: !primaryKeyFound ? 'Tidak ditemukan primary key yang valid' : 
             Object.keys(updateData).length === 0 ? 'Tidak ada data yang akan diupdate' : null
    };

  } catch (error) {
    Logger.log(`‚ùå Error validated preparation: ${error}`);
    // Fallback ke universal approach
    return prepareDataForUpdateUniversal(headers, rowData, sheetName);
  }
}

function prepareDataForUpdateUniversal(headers, rowData, sheetName) {
  const updateData = {};
  const whereCondition = {};
  let primaryKeyFound = false;

  const invalidColumnsForMurid = ['kelas_madin', 'kelas_quran', 'kamar'];
  
  headers.forEach((header, index) => {
    if (!header || header.toString().trim() === '') return;

    let value = rowData[index];
    const cleanHeader = header.toString().toLowerCase().trim();

    if (value === '' || value === undefined || value === null) {
      value = null;
    }

    if (sheetName === 'Data_Murid' && invalidColumnsForMurid.includes(cleanHeader)) {
      return;
    }

    if ((cleanHeader === 'id' || cleanHeader.includes('_id')) && value) {
      whereCondition[header] = value;
      primaryKeyFound = true;
    } else if (!primaryKeyFound && (cleanHeader.includes('email') || cleanHeader.includes('nis') || cleanHeader.includes('nik')) && value) {
      whereCondition[header] = value;
    } else if (!['created_at', 'updated_at', 'timestamp', 'foto', 'foto_profil'].includes(cleanHeader)) {
      updateData[header] = value;
    }
  });

  if (!primaryKeyFound && Object.keys(updateData).length > 0) {
    const uniqueFields = ['email', 'nis', 'nik', 'nama', 'no_hp'];
    for (const field of uniqueFields) {
      const fieldIndex = headers.findIndex(h => h.toString().toLowerCase().includes(field));
      if (fieldIndex !== -1 && rowData[fieldIndex]) {
        whereCondition[headers[fieldIndex]] = rowData[fieldIndex];
        primaryKeyFound = true;
        break;
      }
    }
  }

  Logger.log(`üîß Prepared data for ${sheetName}:`);
  Logger.log(`   Where: ${JSON.stringify(whereCondition)}`);
  Logger.log(`   Update: ${JSON.stringify(updateData)}`);

  return {
    updateData: updateData,
    whereCondition: whereCondition,
    isValid: primaryKeyFound && Object.keys(updateData).length > 0,
    error: !primaryKeyFound ? 'Tidak ditemukan primary key yang valid' : 
           Object.keys(updateData).length === 0 ? 'Tidak ada data yang akan diupdate' : null
  };
}

function prepareDataDirect(headers, rowData, sheetName) {
  try {
    console.log(`üîß Preparing direct data for ${sheetName}...`);
    
    const data = {};
    const whereCondition = {};
    
    for (let i = 0; i < headers.length; i++) {
      const header = headers[i];
      const value = rowData[i];
      
      if (!header || value === undefined || value === null || value === '') {
        continue;
      }
      
      const cleanHeader = header.toString().toLowerCase().trim();
      
      if (cleanHeader.includes('_id')) {
        whereCondition[header] = value;
      }
      
      data[header] = value;
    }
    
    if (Object.keys(whereCondition).length === 0) {
      const idField = getPrimaryKeyForTable(sheetName);
      const idIndex = headers.findIndex(h => 
        h.toString().toLowerCase().includes(idField)
      );
      
      if (idIndex !== -1 && rowData[idIndex]) {
        whereCondition[headers[idIndex]] = rowData[idIndex];
      }
    }
    
    console.log(`üì§ Prepared data for ${sheetName}:`, { data, whereCondition });
    
    return {
      table: sheetName,
      action: 'update',
      data: data,
      where: whereCondition
    };
    
  } catch (error) {
    console.error(`‚ùå Error prepareDataDirect: ${error.toString()}`);
    return null;
  }
}

function prepareDataForUpdateFlexible(headers, rowData, sheetName) {
  try {
    console.log(`üîß Preparing flexible data for ${sheetName}...`);
    
    const updateData = {};
    const whereCondition = {};
    let hasValidId = false;
    
    const validation = validateRowDataFlexibleImproved(headers, rowData);
    
    if (!validation.isValid) {
      console.log(`‚ùå Data tidak valid: ${validation.errors.join(', ')}`);
      return { 
        isValid: false, 
        error: validation.errors.join(', '),
        updateData: {},
        whereCondition: {}
      };
    }
    
    headers.forEach((header, index) => {
      if (!header || header.toString().trim() === '') return;
      
      const value = rowData[index];
      const cleanHeader = header.toString().toLowerCase().trim();
      
      if (value === '' || value === undefined || value === null) {
        return;
      }
      
      if ((cleanHeader === 'id' || cleanHeader.includes('_id')) && value) {
        whereCondition[header] = value;
        hasValidId = true;
      } else if (!['created_at', 'updated_at', 'timestamp'].includes(cleanHeader)) {
        updateData[header] = value;
      }
    });
    
    if (!hasValidId && validation.hasValidId) {
      hasValidId = true;
    }
    
    return {
      isValid: hasValidId && Object.keys(updateData).length > 0,
      updateData: updateData,
      whereCondition: whereCondition,
      error: !hasValidId ? 'Tidak ditemukan ID yang valid' : 
             Object.keys(updateData).length === 0 ? 'Tidak ada data untuk diupdate' : null
    };
    
  } catch (error) {
    console.error(`‚ùå Error prepare flexible: ${error.toString()}`);
    return { 
      isValid: false, 
      error: error.toString(),
      updateData: {},
      whereCondition: {}
    };
  }
}

function prepareDataForUpdateStrict(headers, rowData, sheetName) {
  try {
    console.log(`üîß Preparing strict data for ${sheetName}...`);
    
    const updateData = {};
    const whereCondition = {};
    let hasId = false;
    
    const validation = validateRowDataStrict(headers, rowData);
    
    if (!validation.isValid) {
      console.log(`‚ùå Data tidak valid secara strict: ${validation.errors.join(', ')}`);
      return { 
        isValid: false, 
        error: validation.errors.join(', '),
        updateData: {},
        whereCondition: {}
      };
    }
    
    headers.forEach((header, index) => {
      if (!header || header.toString().trim() === '') return;
      
      const value = rowData[index];
      const cleanHeader = header.toString().toLowerCase().trim();
      
      if ((cleanHeader === 'id' || cleanHeader.includes('_id')) && value) {
        whereCondition[header] = value;
        hasId = true;
      } else if (!['created_at', 'updated_at', 'timestamp'].includes(cleanHeader)) {
        updateData[header] = value;
      }
    });
    
    return {
      isValid: hasId && Object.keys(updateData).length > 0,
      updateData: updateData,
      whereCondition: whereCondition,
      error: !hasId ? 'ID tidak ditemukan' : 
             Object.keys(updateData).length === 0 ? 'Tidak ada data untuk diupdate' : null
    };
    
  } catch (error) {
    console.error(`‚ùå Error prepare strict: ${error.toString()}`);
    return { 
      isValid: false, 
      error: error.toString(),
      updateData: {},
      whereCondition: {}
    };
  }
}

function prepareDataForUpdateSimple(headers, rowData, sheetName) {
  try {
    console.log(`üîß Preparing simple data for ${sheetName}...`);
    
    const updateData = {};
    const whereCondition = {};
    
    const tableName = getTableName(sheetName);
    const primaryKey = getPrimaryKeyForTable(tableName);
    const pkIndex = headers.findIndex(h => 
      h && h.toString().toLowerCase().trim() === primaryKey.toLowerCase()
    );
    
    if (pkIndex === -1 || !rowData[pkIndex]) {
      return { 
        isValid: false, 
        error: `Primary key (${primaryKey}) tidak ditemukan`,
        updateData: {},
        whereCondition: {}
      };
    }
    
    whereCondition[headers[pkIndex]] = rowData[pkIndex];
    
    headers.forEach((header, index) => {
      if (!header || header.toString().trim() === '') return;
      
      const value = rowData[index];
      const cleanHeader = header.toString().toLowerCase().trim();
      
      if (value === '' || value === undefined || value === null) {
        return;
      }
      
      if (cleanHeader === primaryKey.toLowerCase()) {
        return; // Skip primary key for update data
      }
      
      if (!['created_at', 'updated_at', 'timestamp'].includes(cleanHeader)) {
        updateData[header] = value;
      }
    });
    
    return {
      isValid: true,
      updateData: updateData,
      whereCondition: whereCondition,
      error: Object.keys(updateData).length === 0 ? 'Tidak ada data untuk diupdate' : null
    };
    
  } catch (error) {
    console.error(`‚ùå Error prepare simple: ${error.toString()}`);
    return { 
      isValid: false, 
      error: error.toString(),
      updateData: {},
      whereCondition: {}
    };
  }
}

function validateRowDataFlexibleImproved(headers, rowData) {
  const errors = [];
  let hasValidId = false;
  
  for (let i = 0; i < headers.length; i++) {
    const header = headers[i];
    const value = rowData[i];
    
    if (!header || header.toString().trim() === '') continue;
    
    const cleanHeader = header.toString().toLowerCase().trim();
    
    if ((cleanHeader === 'id' || cleanHeader.includes('_id')) && value) {
      if (value !== '' && value !== null && value !== undefined) {
        hasValidId = true;
      }
    }
    
    if ((cleanHeader.includes('nik') || cleanHeader.includes('nis') || cleanHeader.includes('nip')) && value) {
      const strValue = value.toString().trim();
      if (strValue !== '' && !/^\d+$/.test(strValue)) {
        errors.push(`${header} harus numerik (ditemukan: ${strValue})`);
      }
    }
  }
  
  if (!hasValidId) {
    for (let i = 0; i < headers.length; i++) {
      const header = headers[i].toString().toLowerCase();
      if ((header.includes('email') || header.includes('nama')) && rowData[i]) {
        hasValidId = true;
        break;
      }
    }
    
    if (!hasValidId) {
      errors.push('Tidak ditemukan ID atau identifier yang valid');
    }
  }
  
  return {
    isValid: errors.length === 0,
    errors: errors,
    hasValidId: hasValidId
  };
}

function validateRowDataStrict(headers, rowData) {
  const errors = [];
  let hasId = false;
  
  headers.forEach((header, index) => {
    if (!header) return;
    
    const value = rowData[index];
    const cleanHeader = header.toString().toLowerCase().trim();
    
    if ((cleanHeader === 'id' || cleanHeader.includes('_id')) && value) {
      hasId = true;
    }
    
    if ((cleanHeader.includes('nik') || cleanHeader.includes('nis') || cleanHeader.includes('nip')) && value) {
      const strValue = value.toString().trim();
      if (strValue !== '' && !/^\d+$/.test(strValue)) {
        errors.push(`${header} harus angka (ditemukan: ${strValue})`);
      }
    }
    
    if (cleanHeader.includes('nama') && (!value || value.toString().trim() === '')) {
      errors.push(`${header} tidak boleh kosong`);
    }
  });
  
  if (!hasId) {
    errors.push('ID tidak ditemukan atau kosong');
  }
  
  return {
    isValid: errors.length === 0 && hasId,
    errors: errors,
    hasId: hasId
  };
}

function pushSheetDataDirect(sheetName) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    if (!sheet) {
      return { success: false, error: 'Sheet tidak ditemukan', successCount: 0, errorCount: 1, skippedCount: 0 };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    if (data.length <= 1) {
      return { success: true, message: 'Tidak ada data', successCount: 0, errorCount: 0, skippedCount: 0 };
    }
    
    let successCount = 0, errorCount = 0, skippedCount = 0;
    
    Logger.log(`üîÑ ${sheetName}: Processing ${data.length-1} rows secara langsung`);
    
    const batchSize = 20;
    const totalBatches = Math.ceil((data.length - 1) / batchSize);
    
    for (let batch = 0; batch < totalBatches; batch++) {
      const startRow = batch * batchSize + 1;
      const endRow = Math.min(startRow + batchSize, data.length);
      
      if (batch % 10 === 0) {
        Logger.log(`üîÑ Batch ${batch+1}/${totalBatches}: Baris ${startRow}-${endRow-1}`);
      }
      
      for (let i = startRow; i < endRow; i++) {
        const rowData = data[i];
        
        if (isRowEmpty(rowData)) {
          skippedCount++;
          continue;
        }
        
        const preparation = prepareDataDirect(headers, rowData, sheetName);
        
        if (!preparation.isValid) {
          skippedCount++;
          continue;
        }
        
        try {
          const result = updateDataToMySQL(
            getTableName(sheetName), 
            preparation.updateData, 
            preparation.whereCondition
          );
          
          if (result && result.success) {
            successCount++;
          } else if (result && result.skipped) {
            skippedCount++;
          } else {
            errorCount++;
          }
          
        } catch (error) {
          errorCount++;
          if (errorCount <= 5) {
            Logger.log(`‚ùå Error baris ${i+1}: ${error.toString().substring(0, 100)}`);
          }
        }
      }
    }
    
    Logger.log(`üìä ${sheetName}: ${successCount}‚úÖ ${errorCount}‚ùå ${skippedCount}‚è©`);
    
    return {
      success: errorCount === 0,
      successCount, errorCount, skippedCount,
      totalProcessed: successCount + errorCount + skippedCount
    };
    
  } catch (error) {
    Logger.log(`‚ùå Direct processing failed: ${error.toString()}`);
    return {
      success: false,
      error: error.toString(),
      successCount: 0, errorCount: 1, skippedCount: 0
    };
  }
}

function pushSheetDataDirectSimple(sheetName, maxRows = 5) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    if (!sheet) {
      return { success: false, error: 'Sheet tidak ditemukan', successCount: 0, errorCount: 1, skippedCount: 0 };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    if (data.length <= 1) {
      return { success: true, message: 'Tidak ada data', successCount: 0, errorCount: 0, skippedCount: 0 };
    }
    
    let successCount = 0, errorCount = 0, skippedCount = 0;
    
    Logger.log(`‚ö° ${sheetName}: Processing ${Math.min(data.length-1, maxRows)} rows secara simple`);
    
    // Process hanya beberapa baris
    const processRows = Math.min(data.length - 1, maxRows);
    
    for (let i = 1; i <= processRows; i++) {
      const rowData = data[i];
      
      if (isRowEmpty(rowData)) {
        skippedCount++;
        continue;
      }
      
      // Siapkan data sederhana: ambil hanya beberapa kolom kunci
      const updateData = {};
      const whereCondition = {};
      
      // Cari primary key
      const primaryKey = getPrimaryKeyForSheet(sheetName);
      const idIndex = headers.indexOf(primaryKey);
      
      if (idIndex === -1 || !rowData[idIndex]) {
        skippedCount++;
        continue;
      }
      
      whereCondition[primaryKey] = rowData[idIndex];
      
      // Ambil hanya kolom penting
      const importantFields = ['nama', 'email', 'no_hp', 'alamat', 'status'];
      headers.forEach((header, index) => {
        if (importantFields.includes(header.toLowerCase()) && rowData[index]) {
          updateData[header] = rowData[index];
        }
      });
      
      if (Object.keys(updateData).length === 0) {
        skippedCount++;
        continue;
      }
      
      try {
        const result = updateDataToMySQL(
          getTableName(sheetName), 
          updateData, 
          whereCondition
        );
        
        if (result && result.success) {
          successCount++;
        } else {
          errorCount++;
        }
        
      } catch (error) {
        errorCount++;
      }
      
      Utilities.sleep(1500);
    }
    
    Logger.log(`üìä ${sheetName}: ${successCount}‚úÖ ${errorCount}‚ùå ${skippedCount}‚è©`);
    
    return {
      success: errorCount === 0,
      successCount, errorCount, skippedCount
    };
    
  } catch (error) {
    Logger.log(`‚ùå Direct simple processing failed: ${error.toString()}`);
    return {
      success: false,
      error: error.toString(),
      successCount: 0, errorCount: 1, skippedCount: 0
    };
  }
}

function pushSheetDataOptimized(sheetName) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    if (!sheet) {
      return { success: false, error: 'Sheet tidak ditemukan', successCount: 0, errorCount: 1, skippedCount: 0 };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    if (data.length <= 1) {
      return { success: true, message: 'Tidak ada data', successCount: 0, errorCount: 0, skippedCount: 0 };
    }
    
    let successCount = 0, errorCount = 0, skippedCount = 0;
    
    Logger.log(`‚ö° ${sheetName}: Processing ${data.length-1} rows optimized`);
    
    // Gunakan preparasi data yang paling sederhana
    for (let i = 1; i < data.length; i++) {
      const rowData = data[i];
      
      if (isRowEmpty(rowData)) {
        skippedCount++;
        continue;
      }
      
      const preparation = prepareDataDirect(headers, rowData, sheetName);
      
      if (!preparation.isValid) {
        skippedCount++;
        continue;
      }
      
      try {
        const result = updateDataToMySQL(
          getTableName(sheetName), 
          preparation.updateData, 
          preparation.whereCondition
        );
        
        if (result && result.success) {
          successCount++;
        } else if (result && result.skipped) {
          skippedCount++;
        } else {
          errorCount++;
        }
      } catch (error) {
        errorCount++;
      }
      
      // Delay kecil untuk menghindari rate limit
      if (i % 5 === 0) Utilities.sleep(500);
    }
    
    Logger.log(`üìä ${sheetName} Optimized: ${successCount}‚úÖ ${errorCount}‚ùå ${skippedCount}‚è©`);
    
    return {
      success: errorCount === 0,
      successCount, errorCount, skippedCount,
      totalProcessed: successCount + errorCount + skippedCount
    };
  } catch (error) {
    return {
      success: false,
      error: error.toString(),
      successCount: 0, errorCount: 1, skippedCount: 0
    };
  }
}

function pushSheetDataUniversalOptimized(sheetName) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    if (!sheet) {
      return { success: false, error: 'Sheet tidak ditemukan', successCount: 0, errorCount: 1, skippedCount: 0 };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    if (data.length <= 1) {
      return { success: true, message: 'Tidak ada data', successCount: 0, errorCount: 0, skippedCount: 0 };
    }
    
    let successCount = 0, errorCount = 0, skippedCount = 0;
    
    Logger.log(`üîÑ ${sheetName}: Processing ${data.length-1} rows optimized`);
    
    // Process dengan batch size yang optimal
    const batchSize = 10;
    const totalBatches = Math.ceil((data.length - 1) / batchSize);
    
    for (let batch = 0; batch < totalBatches; batch++) {
      const startRow = batch * batchSize + 1;
      const endRow = Math.min(startRow + batchSize, data.length);
      
      Logger.log(`üîÑ Batch ${batch+1}/${totalBatches}: Baris ${startRow}-${endRow-1}`);
      
      for (let i = startRow; i < endRow; i++) {
        const rowData = data[i];
        
        if (isRowEmpty(rowData)) {
          skippedCount++;
          continue;
        }
        
        // Gunakan preparasi data yang sederhana dan efektif
        const preparation = prepareDataForUpdateUniversal(headers, rowData, sheetName);
        
        if (!preparation.isValid) {
          Logger.log(`‚è© Skip baris ${i+1}: ${preparation.error}`);
          skippedCount++;
          continue;
        }
        
        try {
          const result = updateDataToMySQL(
            getTableName(sheetName), 
            preparation.updateData, 
            preparation.whereCondition
          );
          
          if (result && result.success) {
            successCount++;
          } else if (result && result.skipped) {
            skippedCount++;
          } else {
            errorCount++;
          }
          
        } catch (error) {
          errorCount++;
          Logger.log(`‚ùå Error baris ${i+1}: ${error.toString().substring(0, 100)}`);
        }
      }
      
      // Progress update tanpa delay berlebihan
      const progress = Math.round(((batch + 1) / totalBatches) * 100);
      if (progress % 20 === 0) { // Log hanya setiap 20%
        Logger.log(`üìà ${sheetName} Progress: ${progress}%`);
      }
    }
    
    Logger.log(`üìä ${sheetName}: ${successCount}‚úÖ ${errorCount}‚ùå ${skippedCount}‚è©`);
    
    return {
      success: errorCount === 0,
      successCount, errorCount, skippedCount,
      totalProcessed: successCount + errorCount + skippedCount
    };
    
  } catch (error) {
    Logger.log(`‚ùå Optimized processing failed: ${error.toString()}`);
    return {
      success: false,
      error: error.toString(),
      successCount: 0, errorCount: 1, skippedCount: 0
    };
  }
}

function pushSheetDataFlexible(sheetName, maxRows = 20) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    if (!sheet) {
      return { success: false, error: 'Sheet tidak ditemukan', successCount: 0, errorCount: 1, skippedCount: 0 };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    if (data.length <= 1) {
      return { success: true, message: 'Tidak ada data', successCount: 0, errorCount: 0, skippedCount: 0 };
    }
    
    let successCount = 0, errorCount = 0, skippedCount = 0;
    
    Logger.log(`üîÑ ${sheetName}: Processing ${Math.min(data.length-1, maxRows)} rows secara fleksibel`);
    
    // Process dengan batasan baris
    const processRows = Math.min(data.length - 1, maxRows);
    
    for (let i = 1; i <= processRows; i++) {
      const rowData = data[i];
      
      if (isRowEmpty(rowData)) {
        skippedCount++;
        continue;
      }
      
      // Siapkan data fleksibel berdasarkan kolom yang ada
      const updateData = {};
      const whereCondition = {};
      let hasPrimaryKey = false;
      
      // Mapping kolom berdasarkan sheet
      const primaryKeyMap = {
        'Data_Murid': 'murid_id',
        'Data_Guru': 'guru_id', 
        'Data_Users': 'user_id',
        'Data_Alumni': 'alumni_id'
      };
      
      const primaryKey = primaryKeyMap[sheetName] || 'id';
      const pkIndex = headers.indexOf(primaryKey);
      
      // Cari primary key
      if (pkIndex !== -1 && rowData[pkIndex]) {
        whereCondition[primaryKey] = rowData[pkIndex];
        hasPrimaryKey = true;
      } else {
        // Fallback: cari kolom lain yang bisa jadi identifier
        const alternateKeys = ['id', 'email', 'nis', 'nik', 'nama'];
        for (const key of alternateKeys) {
          const keyIndex = headers.indexOf(key);
          if (keyIndex !== -1 && rowData[keyIndex]) {
            whereCondition[key] = rowData[keyIndex];
            hasPrimaryKey = true;
            break;
          }
        }
      }
      
      if (!hasPrimaryKey) {
        skippedCount++;
        continue;
      }
      
      // Kumpulkan data untuk update (exclude primary key dan metadata)
      headers.forEach((header, index) => {
        if (!header || header.toString().trim() === '') return;
        
        const cleanHeader = header.toString().toLowerCase().trim();
        const value = rowData[index];
        
        // Skip jika: kosong, primary key, atau metadata
        if (value === '' || value === null || value === undefined) return;
        if (cleanHeader === primaryKey.toLowerCase()) return;
        if (['created_at', 'updated_at', 'timestamp'].includes(cleanHeader)) return;
        
        updateData[header] = value;
      });
      
      if (Object.keys(updateData).length === 0) {
        skippedCount++;
        continue;
      }
      
      try {
        const result = updateDataToMySQL(
          getTableName(sheetName), 
          updateData, 
          whereCondition
        );
        
        if (result && result.success) {
          successCount++;
        } else if (result && result.skipped) {
          skippedCount++;
        } else {
          errorCount++;
        }
        
      } catch (error) {
        errorCount++;
        if (errorCount <= 3) { // Log hanya 3 error pertama
          Logger.log(`‚ùå Error baris ${i+1}: ${error.toString().substring(0, 100)}`);
        }
      }
      
      Utilities.sleep(1000); // Delay antar request
    }
    
    Logger.log(`üìä ${sheetName}: ${successCount}‚úÖ ${errorCount}‚ùå ${skippedCount}‚è©`);
    
    return {
      success: errorCount === 0,
      successCount, errorCount, skippedCount,
      totalProcessed: successCount + errorCount + skippedCount
    };
    
  } catch (error) {
    Logger.log(`‚ùå Flexible processing failed: ${error.toString()}`);
    return {
      success: false,
      error: error.toString(),
      successCount: 0, errorCount: 1, skippedCount: 0
    };
  }
}

function pushAllDataOptimized() {
  console.log('üöÄ Memulai push data optimized...');
  
  const results = {
    success: 0,
    failed: 0,
    skipped: 0
  };
  
  try {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    
    console.log('üìä Processing Data_Guru...');
    const guruSheet = spreadsheet.getSheetByName('Data_Guru');
    if (guruSheet) {
      const guruData = guruSheet.getDataRange().getValues();
      const guruHeaders = guruData[0];
      
      const maxRows = Math.min(10, guruData.length - 1);
      
      for (let i = 1; i <= maxRows; i++) {
        try {
          const payload = prepareDataDirect(guruHeaders, guruData[i], 'guru');
          if (payload) {
            const response = sendToApi(payload);
            if (response && response.success) {
              results.success++;
              console.log(`‚úÖ Guru baris ${i}: ${response.message}`);
            } else {
              results.failed++;
              console.log(`‚ùå Guru baris ${i}: ${response?.message || 'Gagal'}`);
            }
          } else {
            results.skipped++;
            console.log(`‚è© Guru baris ${i}: Payload tidak valid`);
          }
        } catch (err) {
          results.failed++;
          console.log(`‚ùå Error guru baris ${i}: ${err.message}`);
        }
        
        if (i % 3 === 0) Utilities.sleep(2000);
      }
    }
    
    console.log('üìä Processing Data_Murid with mapping approach...');
    const muridSheet = spreadsheet.getSheetByName('Data_Murid');
    if (muridSheet) {
      const muridData = muridSheet.getDataRange().getValues();
      const muridHeaders = muridData[0];
      
      console.log(`üîÑ Data_Murid: Processing ${muridData.length - 1} rows dengan mapping`);
      
      const muridResult = pushSheetWithMapping('Data_Murid', {
        sheetToDB: {
          'kelas_madin': 'kelas_madin_id',
          'kelas_quran': 'kelas_quran_id',
          'kamar': 'kamar_id'
        }
      });
      
      results.success += muridResult.successCount || 0;
      results.failed += muridResult.errorCount || 0;
      results.skipped += muridResult.skippedCount || 0;
    }
    
    console.log('üìä Processing Data_Users...');
    const usersSheet = spreadsheet.getSheetByName('Data_Users');
    if (usersSheet) {
      const usersData = usersSheet.getDataRange().getValues();
      const usersHeaders = usersData[0];
      
      const maxRows = Math.min(5, usersData.length - 1);
      
      for (let i = 1; i <= maxRows; i++) {
        try {
          const payload = prepareDataDirect(usersHeaders, usersData[i], 'users');
          if (payload) {
            const response = sendToApi(payload);
            if (response && response.success) {
              results.success++;
              console.log(`‚úÖ Users baris ${i}: ${response.message}`);
            } else {
              results.failed++;
              console.log(`‚ùå Users baris ${i}: ${response?.message || 'Gagal'}`);
            }
          } else {
            results.skipped++;
          }
        } catch (err) {
          results.failed++;
          console.log(`‚ùå Error users baris ${i}: ${err.message}`);
        }
        
        Utilities.sleep(1000);
      }
    }
    
    console.log('üìä Processing Data_Alumni...');
    const alumniSheet = spreadsheet.getSheetByName('Data_Alumni');
    if (alumniSheet) {
      const alumniData = alumniSheet.getDataRange().getValues();
      const alumniHeaders = alumniData[0];
      
      for (let i = 1; i < alumniData.length; i++) {
        try {
          const payload = prepareDataDirect(alumniHeaders, alumniData[i], 'alumni');
          if (payload) {
            const response = sendToApi(payload);
            if (response && response.success) {
              results.success++;
              console.log(`‚úÖ Alumni baris ${i}: ${response.message}`);
            } else {
              results.failed++;
              console.log(`‚ùå Alumni baris ${i}: ${response?.message || 'Gagal'}`);
            }
          } else {
            results.skipped++;
          }
        } catch (err) {
          results.failed++;
          console.log(`‚ùå Error alumni baris ${i}: ${err.message}`);
        }
        
        Utilities.sleep(1000);
      }
    }
    
    writeResultsToSummary(results);
    
    const total = results.success + results.failed + results.skipped;
    const successRate = total > 0 ? Math.round((results.success / total) * 100) : 0;
    
    console.log(`üöÄ Push Data Complete: ${results.success}‚úÖ ${results.failed}‚ùå ${results.skipped}‚è© (${successRate}% success)`);
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `Push selesai: ${successRate}% berhasil`,
      '‚ö° Push Data Optimized',
      5
    );
    
    return results;
    
  } catch (error) {
    console.error('‚ùå Error utama pushAllDataOptimized:', error);
    
    SpreadsheetApp.getUi().alert(
      `Error: ${error.message}`,
      '‚ùå Push Data Gagal',
      5
    );
    
    return results;
  }
}

function pushSheetWithMapping(sheetName, mapping = {}) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    if (!sheet) {
      return { success: false, error: 'Sheet tidak ditemukan', successCount: 0, errorCount: 1, skippedCount: 0 };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    if (data.length <= 1) {
      return { success: true, message: 'Tidak ada data', successCount: 0, errorCount: 0, skippedCount: 0 };
    }
    
    let successCount = 0, errorCount = 0, skippedCount = 0;
    const sheetToDB = mapping?.sheetToDB || {};
    const dbToSheet = mapping?.dbToSheet || {};
    
    Logger.log(`üîÑ ${sheetName}: Processing ${data.length-1} rows dengan mapping`);
    
    const tableName = getTableName(sheetName);
    const dbStructure = getDatabaseTableStructureRobust(tableName);
    const dbColumns = dbStructure ? dbStructure.map(col => col.Field) : [];
    
    const maxRows = Math.min(data.length - 1, 10);
    
    for (let i = 1; i <= maxRows; i++) {
      const rowData = data[i];
      
      if (isRowEmpty(rowData)) {
        skippedCount++;
        continue;
      }
      
      const updateData = {};
      const whereCondition = {};
      let hasPrimaryKey = false;
      
      const primaryKeys = ['id', 'murid_id', 'guru_id', 'user_id', 'alumni_id'];
      for (let j = 0; j < headers.length; j++) {
        const header = headers[j];
        if (!header) continue;
        
        const cleanHeader = header.toString().toLowerCase().trim();
        const value = rowData[j];
        
        if (primaryKeys.some(pk => cleanHeader.includes(pk)) && value) {
          const dbField = sheetToDB[header] || header;
          whereCondition[dbField] = value;
          hasPrimaryKey = true;
          break;
        }
      }
      
      if (!hasPrimaryKey) {
        skippedCount++;
        continue;
      }
      
      for (let j = 0; j < headers.length; j++) {
        const header = headers[j];
        if (!header) continue;
        
        const value = rowData[j];
        if (value === '' || value === null || value === undefined) continue;
        
        const cleanHeader = header.toString().toLowerCase().trim();
        if (primaryKeys.some(pk => cleanHeader.includes(pk))) continue;
        
        const dbField = sheetToDB[header] || header;
        
        if (dbColumns.length > 0 && !dbColumns.includes(dbField)) {
          Logger.log(`‚è© Skip kolom ${dbField} - tidak ada di database`);
          continue;
        }
        
        updateData[dbField] = value;
      }
      
      if (Object.keys(updateData).length === 0) {
        skippedCount++;
        continue;
      }
      
      try {
        const result = updateDataToMySQL(tableName, updateData, whereCondition);
        
        if (result && result.success) {
          successCount++;
        } else if (result && result.skipped) {
          skippedCount++;
        } else {
          errorCount++;
        }
        
      } catch (error) {
        errorCount++;
        if (errorCount <= 3) {
          Logger.log(`‚ùå Error baris ${i+1}: ${error.toString().substring(0, 100)}`);
        }
      }
      
      Utilities.sleep(1500);
    }
    
    Logger.log(`üìä ${sheetName}: ${successCount}‚úÖ ${errorCount}‚ùå ${skippedCount}‚è©`);
    
    return {
      success: errorCount === 0,
      successCount, errorCount, skippedCount,
      totalProcessed: successCount + errorCount + skippedCount
    };
    
  } catch (error) {
    Logger.log(`‚ùå Push with mapping failed: ${error.toString()}`);
    return {
      success: false,
      error: error.toString(),
      successCount: 0, errorCount: 1, skippedCount: 0
    };
  }
}

function pushDataWithMapping() {
  try {
    Logger.log('üîÑ Memulai push data dengan mapping referensi...');
    
    // 1. Sync data referensi terlebih dahulu
    syncReferensiData();
    Utilities.sleep(2000);
    
    // 2. Baca data referensi untuk mapping
    const refData = {
      kelasMadin: getRefMapping('Ref_KelasMadin'),
      kamar: getRefMapping('Ref_Kamar'),
      kelasQuran: getRefMapping('Ref_KelasQuran')
    };
    
    // 3. Process Data_Murid dengan mapping
    const sheetName = 'Data_Murid';
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    if (!sheet || sheet.getLastRow() <= 1) {
      throw new Error('Tidak ada data di Data_Murid');
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    let successCount = 0, errorCount = 0, skippedCount = 0;
    
    // Cari index kolom yang perlu mapping
    const idxKelasMadin = headers.indexOf('kelas_madin');
    const idxKamar = headers.indexOf('kamar');
    const idxKelasQuran = headers.indexOf('kelas_quran');
    
    for (let i = 1; i < data.length; i++) {
      const rowData = [...data[i]]; // Copy array
      
      // Mapping nama ke ID
      if (idxKelasMadin !== -1 && rowData[idxKelasMadin]) {
        const namaKelas = rowData[idxKelasMadin];
        if (refData.kelasMadin[namaKelas]) {
          rowData[idxKelasMadin] = refData.kelasMadin[namaKelas];
        } else {
          rowData[idxKelasMadin] = null; // Atau skip jika tidak ditemukan
        }
      }
      
      if (idxKamar !== -1 && rowData[idxKamar]) {
        const namaKamar = rowData[idxKamar];
        if (refData.kamar[namaKamar]) {
          rowData[idxKamar] = refData.kamar[namaKamar];
        } else {
          rowData[idxKamar] = null;
        }
      }
      
      if (idxKelasQuran !== -1 && rowData[idxKelasQuran]) {
        const namaQuran = rowData[idxKelasQuran];
        if (refData.kelasQuran[namaQuran]) {
          rowData[idxKelasQuran] = refData.kelasQuran[namaQuran];
        } else {
          rowData[idxKelasQuran] = null;
        }
      }
      
      // Ganti nama header untuk dikirim ke database
      const modifiedHeaders = headers.map(h => {
        if (h === 'kelas_madin') return 'kelas_madin_id';
        if (h === 'kamar') return 'kamar_id';
        if (h === 'kelas_quran') return 'kelas_quran_id';
        return h;
      });
      
      const preparation = prepareDataForUpdateSimple(modifiedHeaders, rowData, sheetName);
      
      if (!preparation.isValid) {
        skippedCount++;
        continue;
      }
      
      try {
        const result = updateDataToMySQL(
          'murid',
          preparation.updateData,
          preparation.whereCondition
        );
        
        if (result && result.success) {
          successCount++;
        } else {
          errorCount++;
        }
      } catch (error) {
        errorCount++;
      }
      
      Utilities.sleep(500); // Delay antar request
    }
    
    const message = `Mapping Push: ${successCount}‚úÖ ${errorCount}‚ùå ${skippedCount}‚è©`;
    Logger.log(`‚úÖ ${message}`);
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `Push dengan mapping selesai: ${successCount} data berhasil`,
      'Push Data',
      8
    );
    
    return {
      success: errorCount === 0,
      successCount,
      errorCount,
      skippedCount
    };
    
  } catch (error) {
    const errorMsg = `‚ùå Push dengan mapping gagal: ${error.toString()}`;
    Logger.log(errorMsg);
    return { success: false, error: errorMsg };
  }
}

function quickPushTest() {
  try {
    Logger.log('‚ö° Quick push test (5 rows)...');
    
    const sheetName = 'Data_Guru'; // Mulai dengan yang paling stabil
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    
    if (!sheet || sheet.getLastRow() <= 1) {
      SpreadsheetApp.getActiveSpreadsheet().toast('Tidak ada data di Data_Guru', 'Error', 5);
      return;
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    let successCount = 0;
    let errorCount = 0;
    
    // Test 5 baris pertama
    for (let i = 1; i <= Math.min(5, data.length - 1); i++) {
      const rowData = data[i];
      
      // Siapkan data sederhana
      const updateData = {};
      const whereCondition = {};
      
      // Cari primary key
      const guruIdIndex = headers.indexOf('guru_id');
      if (guruIdIndex !== -1 && rowData[guruIdIndex]) {
        whereCondition['guru_id'] = rowData[guruIdIndex];
        
        // Ambil hanya beberapa field penting
        const importantFields = ['nama', 'nip', 'nik', 'no_hp'];
        importantFields.forEach(field => {
          const index = headers.indexOf(field);
          if (index !== -1 && rowData[index]) {
            updateData[field] = rowData[index];
          }
        });
        
        try {
          const result = updateDataToMySQL('guru', updateData, whereCondition);
          
          if (result && result.success) {
            successCount++;
          } else {
            errorCount++;
          }
        } catch (error) {
          errorCount++;
        }
        
        Utilities.sleep(1000);
      }
    }
    
    const message = `Quick test: ${successCount}‚úÖ ${errorCount}‚ùå`;
    SpreadsheetApp.getActiveSpreadsheet().toast(message, 'Quick Test', 5);
    Logger.log(`‚ö° ${message}`);
    
  } catch (error) {
    Logger.log(`‚ùå Quick test gagal: ${error.toString()}`);
  }
}

// =============================================
// 8. FUNGSI REVERENSI & MAPPING
// =============================================
function getReferensiData() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const refData = {
    'kelas_madin_id': {},
    'kelas_quran_id': {},
    'kamar_id': {}
  };
  
  const refSheets = {
    'kelas_madin_id': 'Ref_KelasMadin',
    'kelas_quran_id': 'Ref_KelasQuran',
    'kamar_id': 'Ref_Kamar'
  };
  
  Object.keys(refSheets).forEach(key => {
    const refSheet = spreadsheet.getSheetByName(refSheets[key]);
    if (refSheet && refSheet.getLastRow() > 1) {
      const data = refSheet.getDataRange().getValues();
      for (let i = 1; i < data.length; i++) {
        const id = data[i][0];
        const nama = data[i][1];
        if (id && nama) {
          refData[key][id] = nama;
          refData[key][id.toString().toLowerCase()] = nama;
        }
      }
      console.log(`üìä ${refSheets[key]}: ${Object.keys(refData[key]).length/2} mapping`);
    }
  });
  
  return refData;
}

function fillNotesInBatchEnhanced(sheet, headers, refData) {
  try {
    console.log('üìù Memulai pengisian notes enhanced...');
    
    const lastRow = sheet.getLastRow();
    if (lastRow <= 1) return { processed: 0, notesAdded: 0 };
    
    const refColumns = ['kelas_madin_id', 'kelas_quran_id', 'kamar_id'];
    const columnIndices = {};
    
    // Cari indeks kolom referensi
    refColumns.forEach(col => {
      const idx = headers.indexOf(col);
      if (idx !== -1) {
        columnIndices[col] = idx + 1;
        console.log(`‚úÖ Kolom ${col} ditemukan di kolom ${idx + 1}`);
      } else {
        console.log(`‚ùå Kolom ${col} tidak ditemukan di headers`);
      }
    });
    
    if (Object.keys(columnIndices).length === 0) {
      console.log('‚ö†Ô∏è Tidak ada kolom referensi ditemukan');
      return { processed: 0, notesAdded: 0 };
    }
    
    let notesAdded = 0;
    let processed = 0;
    
    // Proses per baris dengan logging detail
    for (let row = 2; row <= lastRow; row++) {
      refColumns.forEach(col => {
        const colIndex = columnIndices[col];
        if (!colIndex) return;
        
        const cell = sheet.getRange(row, colIndex);
        const idValue = cell.getValue();
        
        if (idValue && idValue !== '') {
          const idStr = idValue.toString().trim();
          
          // Debug logging untuk beberapa baris pertama
          if (row <= 5) {
            console.log(`üîç Baris ${row}, ${col}: ID="${idStr}"`);
          }
          
          // Cari mapping dengan berbagai format
          let nama = null;
          
          // 1. Exact match
          if (refData[col] && refData[col][idStr]) {
            nama = refData[col][idStr];
          }
          // 2. Match dengan lowercase
          else if (refData[col] && refData[col][idStr.toLowerCase()]) {
            nama = refData[col][idStr.toLowerCase()];
          }
          // 3. Cari di semua key (termasuk ID sebagai string)
          else if (refData[col]) {
            for (const [key, value] of Object.entries(refData[col])) {
              if (key.toString() === idStr || 
                  key.toString().toLowerCase() === idStr.toLowerCase()) {
                nama = value;
                break;
              }
            }
          }
          
          if (nama) {
            // Cek jika note sudah ada dan sama
            const existingNote = cell.getNote();
            if (existingNote !== nama) {
              cell.setNote(nama);
              notesAdded++;
              
              if (row <= 5) {
                console.log(`   ‚úÖ Note ditambahkan: "${nama}"`);
              }
            }
          } else if (row <= 5) {
            console.log(`   ‚ùå Mapping tidak ditemukan untuk ID: ${idStr}`);
            console.log(`   Available keys: ${refData[col] ? Object.keys(refData[col]).slice(0, 5).join(', ') : 'none'}`);
          }
        }
      });
      processed++;
      
      // Update progress setiap 50 baris
      if (row % 50 === 0) {
        console.log(`üìä Progress: ${row}/${lastRow} rows, ${notesAdded} notes`);
      }
    }
    
    console.log(`‚úÖ Selesai: ${processed} baris diproses, ${notesAdded} notes ditambahkan`);
    return { processed, notesAdded };
    
  } catch (error) {
    console.error(`‚ùå Error fillNotesInBatchEnhanced: ${error.toString()}`);
    return { processed: 0, notesAdded: 0, error: error.toString() };
  }
}

function getRefMapping(sheetName) {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = spreadsheet.getSheetByName(sheetName);
  
  if (!sheet || sheet.getLastRow() <= 1) {
    return {};
  }
  
  const data = sheet.getDataRange().getValues();
  const mapping = {};
  
  // Baris 1 adalah header
  for (let i = 1; i < data.length; i++) {
    const id = data[i][0];
    const nama = data[i][1];
    if (id && nama) {
      mapping[nama] = id;
    }
  }
  
  return mapping;
}

function mapColumnToField(columnName, tableName) {
  // Mapping sederhana - kembalikan nama kolom asli jika tidak ada mapping
  return columnName;
}

function fillNotesInBatch(sheet, headers, refData) {
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) return;
  
  const refColumns = ['kelas_madin_id', 'kelas_quran_id', 'kamar_id'];
  const columnIndices = {};
  
  refColumns.forEach(col => {
    const idx = headers.indexOf(col);
    if (idx !== -1) {
      columnIndices[col] = idx + 1;
    }
  });
  
  const batchSize = 100;
  let processed = 0;
  let notesAdded = 0;
  
  for (let startRow = 2; startRow <= lastRow; startRow += batchSize) {
    const endRow = Math.min(startRow + batchSize - 1, lastRow);
    
    console.log(`üîÑ Processing rows ${startRow} to ${endRow}`);
    
    for (let row = startRow; row <= endRow; row++) {
      refColumns.forEach(col => {
        const colIndex = columnIndices[col];
        if (colIndex) {
          const cell = sheet.getRange(row, colIndex);
          const id = cell.getValue();
          
          if (id) {
            let nama = null;
            const idStr = id.toString();
            
            if (refData[col] && refData[col][idStr]) {
              nama = refData[col][idStr];
            } else if (refData[col] && refData[col][idStr.toLowerCase()]) {
              nama = refData[col][idStr.toLowerCase()];
            }
            
            if (nama) {
              cell.setNote(nama);
              notesAdded++;
            }
          }
        }
      });
      processed++;
    }
    
    if (endRow < lastRow) {
      Utilities.sleep(500);
    }
  }
  
  console.log(`üìù ${notesAdded} notes added to ${processed} rows`);
  return { processed, notesAdded };
}

function fillNotesInBatchEnhanced(sheet, headers, refData) {
  try {
    console.log('üìù Memulai pengisian notes enhanced...');
    
    const lastRow = sheet.getLastRow();
    if (lastRow <= 1) return { processed: 0, notesAdded: 0 };
    
    const refColumns = ['kelas_madin_id', 'kelas_quran_id', 'kamar_id'];
    const columnIndices = {};
    
    // Cari indeks kolom referensi
    refColumns.forEach(col => {
      const idx = headers.indexOf(col);
      if (idx !== -1) {
        columnIndices[col] = idx + 1;
        console.log(`‚úÖ Kolom ${col} ditemukan di kolom ${idx + 1}`);
      } else {
        console.log(`‚ùå Kolom ${col} tidak ditemukan di headers`);
      }
    });
    
    if (Object.keys(columnIndices).length === 0) {
      console.log('‚ö†Ô∏è Tidak ada kolom referensi ditemukan');
      return { processed: 0, notesAdded: 0 };
    }
    
    let notesAdded = 0;
    let processed = 0;
    
    // Proses per baris dengan logging detail
    for (let row = 2; row <= lastRow; row++) {
      refColumns.forEach(col => {
        const colIndex = columnIndices[col];
        if (!colIndex) return;
        
        const cell = sheet.getRange(row, colIndex);
        const idValue = cell.getValue();
        
        if (idValue && idValue !== '') {
          const idStr = idValue.toString().trim();
          
          // Debug logging untuk beberapa baris pertama
          if (row <= 5) {
            console.log(`üîç Baris ${row}, ${col}: ID="${idStr}"`);
          }
          
          // Cari mapping dengan berbagai format
          let nama = null;
          
          // 1. Exact match
          if (refData[col] && refData[col][idStr]) {
            nama = refData[col][idStr];
          }
          // 2. Match dengan lowercase
          else if (refData[col] && refData[col][idStr.toLowerCase()]) {
            nama = refData[col][idStr.toLowerCase()];
          }
          // 3. Cari di semua key (termasuk ID sebagai string)
          else if (refData[col]) {
            for (const [key, value] of Object.entries(refData[col])) {
              if (key.toString() === idStr || 
                  key.toString().toLowerCase() === idStr.toLowerCase()) {
                nama = value;
                break;
              }
            }
          }
          
          if (nama) {
            // Cek jika note sudah ada dan sama
            const existingNote = cell.getNote();
            if (existingNote !== nama) {
              cell.setNote(nama);
              notesAdded++;
              
              if (row <= 5) {
                console.log(`   ‚úÖ Note ditambahkan: "${nama}"`);
              }
            }
          } else if (row <= 5) {
            console.log(`   ‚ùå Mapping tidak ditemukan untuk ID: ${idStr}`);
            console.log(`   Available keys: ${refData[col] ? Object.keys(refData[col]).slice(0, 5).join(', ') : 'none'}`);
          }
        }
      });
      processed++;
      
      // Update progress setiap 50 baris
      if (row % 50 === 0) {
        console.log(`üìä Progress: ${row}/${lastRow} rows, ${notesAdded} notes`);
      }
    }
    
    console.log(`‚úÖ Selesai: ${processed} baris diproses, ${notesAdded} notes ditambahkan`);
    return { processed, notesAdded };
    
  } catch (error) {
    console.error(`‚ùå Error fillNotesInBatchEnhanced: ${error.toString()}`);
    return { processed: 0, notesAdded: 0, error: error.toString() };
  }
}

// =============================================
// 9. FUNGSI TRIGGER & EVENT HANDLER
// =============================================
function setupEditTrigger() {
  try {
    nonaktifkanEditTrigger();
    
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    ScriptApp.newTrigger('onEditHandler')
      .forSpreadsheet(spreadsheet)
      .onEdit()
      .create();
    
    return true;
  } catch (error) {
    return false;
  }
}

function nonaktifkanEditTrigger() {
  const triggers = ScriptApp.getProjectTriggers();
  let deletedCount = 0;
  
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'onEditHandler') {
      ScriptApp.deleteTrigger(trigger);
      deletedCount++;
    }
  });
  
  return deletedCount;
}

function setupSimpleEditTrigger() {
  try {
    // Hapus trigger lama
    const triggers = ScriptApp.getProjectTriggers();
    triggers.forEach(trigger => {
      if (trigger.getHandlerFunction().includes('onEdit')) {
        ScriptApp.deleteTrigger(trigger);
      }
    });
    
    // Setup trigger baru yang sederhana
    ScriptApp.newTrigger('onEditSimpleHandler')
      .forSpreadsheet(SpreadsheetApp.getActiveSpreadsheet())
      .onEdit()
      .create();
    
    console.log('‚úÖ Simple edit trigger setup complete');
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      '‚úÖ Sistem auto-sync sederhana aktif!',
      'Setup Berhasil',
      5
    );
    
    return true;
    
  } catch (error) {
    console.error(`‚ùå Setup trigger failed: ${error.toString()}`);
    return false;
  }
}

function deleteAllTriggers() {
  ScriptApp.getProjectTriggers().forEach(trigger => {
    ScriptApp.deleteTrigger(trigger);
  });
  console.log('üóëÔ∏è Semua trigger dihapus');
}

function setupSistemSederhana() {
  deleteAllTriggers();
  setupSimpleEditTrigger();
  SpreadsheetApp.getActiveSpreadsheet().toast('Sistem sederhana aktif!', 'Info', 5);
}

function setupSistemLengkap() {
  try {
    SpreadsheetApp.getActiveSpreadsheet().toast('Memulai setup sistem...', 'Setup Sistem', 3);
    
    const apiTest = testAPIConnection();
    if (apiTest.includes('ERROR')) {
      throw new Error('Koneksi API gagal: ' + apiTest);
    }
    
    const triggerResult = setupEditTrigger();
    if (!triggerResult || !checkEditTrigger()) {
      throw new Error('Edit trigger tidak aktif setelah setup');
    }
    
    const syncResults = [];
    const criticalSyncFunctions = [
      { name: 'Murid', func: syncDataMuridViaAPI },
      { name: 'Guru', func: syncDataGuruViaAPI },
      { name: 'Alumni', func: syncDataAlumniViaAPI }
    ];
    
    criticalSyncFunctions.forEach(({ name, func }) => {
      try {
        const result = func();
        syncResults.push(result);
        Utilities.sleep(1000);
      } catch (error) {
        const errorMsg = `ERROR: Gagal sinkron ${name} - ${error.toString()}`;
        syncResults.push(errorMsg);
      }
    });
    
    tampilkanSummary(syncResults);
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Setup sistem lengkap selesai! Edit dua arah sudah aktif.',
      'Setup Berhasil',
      10
    );
    
    return {
      success: true,
      message: 'Setup sistem lengkap selesai',
      results: syncResults
    };
  } catch (error) {
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `Error setup: ${error.message || error.toString()}`,
      'Setup Gagal',
      10
    );
    
    return {
      success: false,
      error: error.message || error.toString()
    };
  }
}

function checkEditTrigger() {
  const triggers = ScriptApp.getProjectTriggers();
  let found = false;
  
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'onEditHandler') {
      found = true;
    }
  });
  
  return found;
}

function checkAutoTriggersStatus() {
  try {
    const triggers = ScriptApp.getProjectTriggers();
    const autoTriggers = ['autoSyncScheduled', 'autoPushScheduled', 'quickAutoSync'];
    
    const status = {
      total: triggers.length,
      auto: [],
      manual: [],
      nextRuns: []
    };
    
    triggers.forEach(trigger => {
      const handler = trigger.getHandlerFunction();
      const triggerType = trigger.getEventType();
      
      if (autoTriggers.includes(handler)) {
        status.auto.push({
          handler: handler,
          type: triggerType,
          source: trigger.getTriggerSource()
        });
      } else {
        status.manual.push({
          handler: handler, 
          type: triggerType,
          source: trigger.getTriggerSource()
        });
      }
    });
    
    // Tampilkan status
    const sheet = buatSummarySheet();
    sheet.clear();
    
    let row = 1;
    sheet.getRange(row, 1).setValue('‚è∞ STATUS TRIGGER OTOMATIS').setFontWeight("bold").setFontSize(16);
    row += 2;
    
    sheet.getRange(row, 1).setValue(`Total Trigger: ${status.total}`);
    row++;
    sheet.getRange(row, 1).setValue(`Auto Triggers: ${status.auto.length}`);
    row++;
    sheet.getRange(row, 1).setValue(`Manual Triggers: ${status.manual.length}`);
    row += 2;
    
    if (status.auto.length > 0) {
      sheet.getRange(row, 1).setValue('üîß AUTO TRIGGERS:').setFontWeight("bold");
      row++;
      
      status.auto.forEach(trigger => {
        sheet.getRange(row, 1).setValue(`‚Ä¢ ${trigger.handler} (${trigger.type})`);
        row++;
      });
    } else {
      sheet.getRange(row, 1).setValue('‚ö†Ô∏è Tidak ada trigger otomatis').setFontColor('#FF9800');
      row++;
      sheet.getRange(row, 1).setValue('Gunakan "Setup Auto Sync" untuk membuat trigger');
      row++;
    }
    
    sheet.autoResizeColumn(1);
    
    const message = status.auto.length > 0 ? 
      `‚úÖ ${status.auto.length} trigger otomatis aktif` :
      '‚ö†Ô∏è Tidak ada trigger otomatis';
    
    SpreadsheetApp.getActiveSpreadsheet().toast(message, 'Trigger Status', 5);
    
    return status;
    
  } catch (error) {
    Logger.log(`‚ùå Cek status trigger gagal: ${error.toString()}`);
    return { error: error.toString() };
  }
}

function onEditHandler(e) {
  if (e.source && e.source !== SpreadsheetApp.getActiveSpreadsheet()) {
    return;
  }
  
  try {
    const range = e.range;
    const sheet = range.getSheet();
    const sheetName = sheet.getName();
    const row = range.getRow();
    const column = range.getColumn();
    
    if (row <= 2 || column === 1) {
      return;
    }
    
    const tableMap = {
      'Data_Murid': 'murid',
      'Data_Guru': 'guru', 
      'Data_Users': 'users',
      'Data_Absensi': 'absensi',
      'Data_Pelanggaran': 'pelanggaran',
      'Data_Perizininan': 'perizinan',
      'Data_Alumni': 'alumni'
    };
    
    const tableName = tableMap[sheetName];
    if (!tableName) return;
    
    Utilities.sleep(2000);
    
    const dataRange = sheet.getRange(row, 1, 1, Math.min(sheet.getLastColumn(), 10));
    const rowData = dataRange.getValues()[0];
    const headers = sheet.getRange(1, 1, 1, Math.min(sheet.getLastColumn(), 10)).getValues()[0];
    
    const updateData = {};
    const whereCondition = {};
    let hasValidData = false;
    
    headers.forEach((header, index) => {
      if (header && header.trim() !== '' && rowData[index] !== undefined && rowData[index] !== '') {
        const value = rowData[index];
        const cleanHeader = header.trim().toLowerCase();
        
        if (cleanHeader.includes('_id') || cleanHeader === 'id') {
          whereCondition[header] = value;
        } else if (!['created_at', 'updated_at', 'foto', 'foto_profil', 'timestamp'].includes(cleanHeader)) {
          updateData[header] = value;
          hasValidData = true;
        }
      }
    });
    
    if (Object.keys(whereCondition).length === 0 || !hasValidData) {
      return;
    }
    
    SpreadsheetApp.getActiveSpreadsheet().toast('üîÑ Menyinkronkan ke database...', 'Memproses', 2);
    
    let retryCount = 0;
    const maxRetries = 2;
    
    while (retryCount <= maxRetries) {
      try {
        const result = updateDataToMySQL(tableName, updateData, whereCondition);
        
        if (result && result.success) {
          SpreadsheetApp.getActiveSpreadsheet().toast('‚úÖ Data tersinkronisasi ke database', 'Berhasil', 3);
          break;
        }
      } catch (error) {
        retryCount++;
        if (retryCount > maxRetries) {
          let errorMessage = 'Gagal sinkronisasi';
          if (error.toString().includes('Timeout')) errorMessage = 'Timeout - coba lagi nanti';
          else if (error.toString().includes('JSON')) errorMessage = 'Error format data';
          
          SpreadsheetApp.getActiveSpreadsheet().toast(`‚ùå ${errorMessage}`, 'Sync Gagal', 5);
          break;
        }
        Utilities.sleep(1000 * retryCount);
      }
    }
  } catch (error) {
    // Error handling sudah dilakukan di dalam loop
  }
}

function onEditSimpleHandler(e) {
  try {
    if (!e || !e.range) return;
    
    const sheet = e.range.getSheet();
    const sheetName = sheet.getName();
    const row = e.range.getRow();
    const col = e.range.getColumn();
    
    // Skip header dan kolom pertama
    if (row <= 2 || col === 1) return;
    
    // Hanya proses sheet tertentu
    const monitoredSheets = ['Data_Murid', 'Data_Guru', 'Data_Users', 'Data_Alumni'];
    if (!monitoredSheets.includes(sheetName)) return;
    
    // Debounce - tunggu 2 detik sebelum memproses
    Utilities.sleep(2000);
    
    // Tampilkan notifikasi
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `üîÑ Menyinkronkan perubahan di ${sheetName} baris ${row}...`,
      'Auto-Sync',
      2
    );
    
    // Ambil data baris yang diubah
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const rowData = data[row - 1]; // -1 karena array 0-indexed
    
    // Siapkan data untuk update
    const preparation = prepareDataForUpdateSimple(headers, rowData, sheetName);
    
    if (!preparation.isValid) {
      console.log(`‚è© Skip baris ${row}: ${preparation.error}`);
      return;
    }
    
    // Kirim update ke database
    try {
      const tableName = getTableName(sheetName);
      const result = updateDataToMySQL(
        tableName,
        preparation.updateData,
        preparation.whereCondition
      );
      
      if (result && result.success) {
        SpreadsheetApp.getActiveSpreadsheet().toast(
          `‚úÖ Data baris ${row} tersinkronisasi`,
          'Sync Success',
          3
        );
        
        // Log aktivitas
        console.log(`‚úÖ Auto-sync: ${sheetName} row ${row} updated`);
      } else {
        SpreadsheetApp.getActiveSpreadsheet().toast(
          `‚ùå Gagal sinkron baris ${row}`,
          'Sync Failed',
          5
        );
      }
      
    } catch (error) {
      console.error(`‚ùå Auto-sync error: ${error.toString()}`);
      SpreadsheetApp.getActiveSpreadsheet().toast(
        `‚ö†Ô∏è Error sync: ${error.toString().substring(0, 50)}`,
        'Sync Error',
        5
      );
    }
    
  } catch (error) {
    // Jangan tampilkan error untuk handler sederhana
    console.error(`‚ùå onEditSimpleHandler error: ${error.toString()}`);
  }
}

function setupRealtimeEditTrigger() {
  try {
    // Hapus trigger lama
    nonaktifkanEditTrigger();
    
    // Buat trigger baru
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    ScriptApp.newTrigger('onEditHandler')
      .forSpreadsheet(spreadsheet)
      .onEdit()
      .create();
    
    console.log('‚úÖ Realtime edit trigger setup complete');
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      '‚úÖ Sistem realtime sync aktif!',
      'Trigger Setup',
      5
    );
    
    return true;
    
  } catch (error) {
    console.error(`‚ùå Setup realtime trigger failed: ${error.toString()}`);
    return false;
  }
}

// =============================================
// 10. FUNGSI BACKUP & CLEANUP
// =============================================
function backupDataBeforePush() {
  try {
    const timestamp = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyyMMdd_HHmmss');
    const backupSheetName = `BACKUP_${timestamp}`;
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    
    const sheetsToBackup = ['Data_Murid', 'Data_Guru', 'Data_Users', 'Data_Alumni'];
    
    sheetsToBackup.forEach(sheetName => {
      const sourceSheet = spreadsheet.getSheetByName(sheetName);
      if (sourceSheet) {
        const backupSheet = spreadsheet.insertSheet(`${sheetName}_${timestamp}`);
        sourceSheet.getDataRange().copyTo(backupSheet.getDataRange());
        console.log(`‚úÖ Backup created: ${backupSheet.getName()}`);
      }
    });
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `Backup created: ${backupSheetName}`,
      'Backup Success',
      5
    );
    
    return { success: true, backupName: backupSheetName };
    
  } catch (error) {
    console.error('‚ùå Backup failed:', error.toString());
    return { success: false, error: error.toString() };
  }
}

function cleanupInvalidColumns() {
  try {
    Logger.log('üßπ Membersihkan kolom tidak valid...');
    
    const cleanupResults = [];
    const sheetsToClean = ['Data_Murid', 'Data_Guru', 'Data_Users', 'Data_Alumni'];
    
    for (const sheetName of sheetsToClean) {
      const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
      if (!sheet) continue;
      
      const currentHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
      Logger.log(`üìã ${sheetName} headers: ${currentHeaders.join(', ')}`);
      
      // Identifikasi kolom yang bermasalah
      const invalidColumns = [];
      const validColumns = [];
      
      currentHeaders.forEach(header => {
        if (header && header.toString().trim() !== '') {
          const cleanHeader = header.toString().trim().toLowerCase();
          
          // Kolom yang diketahui bermasalah
          if (cleanHeader.includes('kelas_madin') || 
              cleanHeader.includes('kelas_quran') || 
              cleanHeader.includes('kamar') ||
              cleanHeader.includes('nilai')) {
            invalidColumns.push(header);
          } else {
            validColumns.push(header);
          }
        }
      });
      
      if (invalidColumns.length > 0) {
        Logger.log(`üóëÔ∏è ${sheetName} - Kolom invalid: ${invalidColumns.join(', ')}`);
        
        // Buat sheet baru dengan kolom valid saja
        const newSheet = buatSheet(sheetName + '_CLEANED');
        newSheet.getRange(1, 1, 1, validColumns.length).setValues([validColumns]);
        
        // Copy data yang ada (jika ada)
        if (sheet.getLastRow() > 1) {
          const dataRange = sheet.getDataRange();
          const allData = dataRange.getValues();
          
          const cleanedData = allData.map(row => {
            const newRow = [];
            currentHeaders.forEach((header, index) => {
              if (validColumns.includes(header)) {
                newRow.push(row[index]);
              }
            });
            return newRow;
          });
          
          newSheet.getRange(1, 1, cleanedData.length, validColumns.length).setValues(cleanedData);
        }
        
        // Format header
        const headerRange = newSheet.getRange(1, 1, 1, validColumns.length);
        headerRange.setFontWeight("bold")
                  .setBackground('#4CAF50')
                  .setFontColor('white');
        
        // Auto resize
        for (let col = 1; col <= validColumns.length; col++) {
          newSheet.autoResizeColumn(col);
        }
        
        cleanupResults.push(`‚úÖ ${sheetName}: Dibersihkan ${invalidColumns.length} kolom invalid`);
        
      } else {
        cleanupResults.push(`‚úÖ ${sheetName}: Tidak ada kolom invalid`);
      }
    }
    
    const result = cleanupResults.join('\n');
    Logger.log(`üìä HASIL CLEANUP:\n${result}`);
    
    return { success: true, results: cleanupResults };
    
  } catch (error) {
    const errorMsg = `‚ùå Cleanup gagal: ${error.toString()}`;
    Logger.log(errorMsg);
    return { success: false, error: errorMsg };
  }
}

function cleanupOldLogs() {
  try {
    const maxLogDays = 7; // Simpan log 7 hari terakhir
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheets = spreadsheet.getSheets();
    
    let deletedCount = 0;
    
    sheets.forEach(sheet => {
      const sheetName = sheet.getName();
      
      // Cari sheet backup/log lama
      if (sheetName.startsWith('BACKUP_') || sheetName.startsWith('LOG_')) {
        try {
          // Parse tanggal dari nama sheet
          const dateStr = sheetName.split('_')[1];
          if (dateStr) {
            const logDate = new Date(
              dateStr.substring(0, 4), // tahun
              parseInt(dateStr.substring(4, 6)) - 1, // bulan (0-based)
              dateStr.substring(6, 8) // hari
            );
            
            const daysOld = Math.floor((new Date() - logDate) / (1000 * 60 * 60 * 24));
            
            if (daysOld > maxLogDays) {
              spreadsheet.deleteSheet(sheet);
              deletedCount++;
              Logger.log(`üóëÔ∏è Hapus log lama: ${sheetName} (${daysOld} hari)`);
            }
          }
        } catch (e) {
          // Skip jika tidak bisa parse tanggal
        }
      }
    });
    
    if (deletedCount > 0) {
      Logger.log(`‚úÖ Cleanup: ${deletedCount} log lama dihapus`);
    }
    
    return { deleted: deletedCount };
    
  } catch (error) {
    Logger.log(`‚ö†Ô∏è Cleanup logs error: ${error.toString()}`);
    return { error: error.toString() };
  }
}

function cleanupOldRetries() {
  try {
    const properties = PropertiesService.getScriptProperties();
    const retries = JSON.parse(properties.getProperty('pending_retries') || '[]');
    
    const now = Date.now();
    const expiredRetries = retries.filter(r => 
      (now - r.createdAt) > (24 * 60 * 60 * 1000) // 24 jam
    );
    
    if (expiredRetries.length > 0) {
      // Hapus expired retries
      const validRetries = retries.filter(r => 
        (now - r.createdAt) <= (24 * 60 * 60 * 1000)
      );
      
      properties.setProperty('pending_retries', JSON.stringify(validRetries));
      
      // Hapus trigger yang expired
      expiredRetries.forEach(retry => {
        deleteRetryTrigger(retry.id);
      });
      
      console.log(`üßπ Cleaned up ${expiredRetries.length} expired retries`);
    }
    
  } catch (error) {
    console.error(`‚ùå Cleanup retries failed: ${error.toString()}`);
  }
}

function deleteRetryTrigger(retryId) {
  try {
    const triggers = ScriptApp.getProjectTriggers();
    let deleted = false;
    
    triggers.forEach(trigger => {
      if (trigger.getHandlerFunction() === `retryPush_${retryId}`) {
        ScriptApp.deleteTrigger(trigger);
        deleted = true;
        console.log(`üóëÔ∏è Deleted retry trigger: ${retryId}`);
      }
    });
    
    return deleted;
    
  } catch (error) {
    console.error(`‚ùå Error deleting retry trigger: ${error.toString()}`);
    return false;
  }
}

function restoreDataMuridDariBackup() {
  try {
    console.log('üîÑ Restore data dari backup...');
    
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const backupSheet = spreadsheet.getSheetByName('DATA_MURID_BACKUP');
    
    if (!backupSheet) {
      throw new Error('Backup tidak ditemukan! Jalankan backup terlebih dahulu.');
    }
    
    const muridSheet = spreadsheet.getSheetByName('Data_Murid');
    if (!muridSheet) {
      throw new Error('Sheet Data_Murid tidak ditemukan');
    }
    
    // Ambil data dari backup (hanya data utama, bukan metadata)
    const backupData = backupSheet.getDataRange().getValues();
    const lastDataColumn = muridSheet.getLastColumn();
    
    // Hanya copy data utama (tidak termasuk kolom timestamp backup)
    const dataToRestore = backupData.map(row => row.slice(0, lastDataColumn));
    
    // Clear data lama dan masukkan data backup
    muridSheet.clear();
    muridSheet.getRange(1, 1, dataToRestore.length, lastDataColumn).setValues(dataToRestore);
    
    console.log(`‚úÖ Restore berhasil: ${dataToRestore.length - 1} data dipulihkan`);
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `‚úÖ ${dataToRestore.length - 1} data berhasil direstore dari backup`,
      'Restore Success',
      5
    );
    
    return {
      success: true,
      restoredCount: dataToRestore.length - 1
    };
    
  } catch (error) {
    console.error(`‚ùå Restore gagal: ${error.toString()}`);
    SpreadsheetApp.getActiveSpreadsheet().toast(`‚ùå Restore gagal: ${error.message}`, 'Error', 10);
    return { success: false, error: error.toString() };
  }
}

function syncDataMuridDenganBackup() {
  try {
    console.log('üîÑ Memulai sync dengan backup otomatis...');
    
    // 1. Buat backup dulu
    const backupResult = backupDataMuridEfisien();
    
    if (!backupResult.success) {
      console.log('‚ö†Ô∏è Backup gagal, tapi sync tetap dilanjutkan');
    }
    
    // 2. Jalankan sync seperti biasa
    const syncResult = syncDataMuridWithNotesEnhancedAman();
    
    console.log(`üìä Hasil: ${syncResult}`);
    
    // 3. Tampilkan status backup
    if (backupResult.success) {
      SpreadsheetApp.getActiveSpreadsheet().toast(
        `Sync selesai! Backup dibuat: ${backupResult.dataCount} data`,
        '‚úÖ Sync dengan Backup',
        5
      );
    }
    
    return {
      backup: backupResult,
      sync: syncResult
    };
    
  } catch (error) {
    console.error(`‚ùå Sync dengan backup gagal: ${error.toString()}`);
    return { success: false, error: error.toString() };
  }
}

function cekStatusBackup() {
  try {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const backupSheet = spreadsheet.getSheetByName('DATA_MURID_BACKUP');
    
    if (!backupSheet) {
      return {
        exists: false,
        message: '‚ùå Tidak ada backup tersimpan'
      };
    }
    
    // Cari timestamp di sheet backup
    const backupData = backupSheet.getDataRange().getValues();
    let timestamp = 'Tidak diketahui';
    let dataCount = 0;
    
    // Cari metadata backup (biasanya di kolom terakhir)
    for (let i = 0; i < Math.min(5, backupData.length); i++) {
      for (let j = 0; j < backupData[i].length; j++) {
        if (backupData[i][j] && backupData[i][j].toString().includes('BACKUP TIMESTAMP:')) {
          timestamp = backupData[i][j + 1] || 'Tidak diketahui';
        }
        if (backupData[i][j] && backupData[i][j].toString().includes('TOTAL DATA:')) {
          dataCount = backupData[i][j + 1] || 0;
        }
      }
    }
    
    const result = {
      exists: true,
      timestamp: timestamp,
      dataCount: dataCount,
      message: `‚úÖ Backup tersedia: ${dataCount} data (${timestamp})`
    };
    
    console.log(result.message);
    
    const ui = SpreadsheetApp.getUi();
    ui.alert(
      'üîê STATUS BACKUP DATA_MURID',
      `Status Backup:\n\n` +
      `üìä Data tersimpan: ${dataCount} data\n` +
      `üïê Timestamp: ${timestamp}\n` +
      `üìÅ Lokasi: Sheet "DATA_MURID_BACKUP" (tersembunyi)\n\n` +
      `Gunakan "Restore Data dari Backup" jika perlu mengembalikan data.`,
      ui.ButtonSet.OK
    );
    
    return result;
    
  } catch (error) {
    console.error(`‚ùå Cek status backup gagal: ${error.toString()}`);
    return { exists: false, error: error.toString() };
  }
}

function hapusBackupLama() {
  try {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const backupSheet = spreadsheet.getSheetByName('DATA_MURID_BACKUP');
    
    if (backupSheet) {
      spreadsheet.deleteSheet(backupSheet);
      console.log('üóëÔ∏è Backup lama dihapus');
      return { success: true, message: 'Backup lama dihapus' };
    }
    
    return { success: false, message: 'Tidak ada backup untuk dihapus' };
    
  } catch (error) {
    console.error(`‚ùå Hapus backup gagal: ${error.toString()}`);
    return { success: false, error: error.toString() };
  }
}

function cleanupOldBackupSheets(maxBackups = 3) {
  try {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheets = spreadsheet.getSheets();
    
    // Kumpulkan semua sheet backup
    const backupSheets = [];
    
    sheets.forEach(sheet => {
      const sheetName = sheet.getName();
      if (sheetName.startsWith('BACKUP_') || sheetName === 'DATA_MURID_BACKUP') {
        try {
          // Coba parse tanggal dari nama sheet
          let timestamp = new Date(0);
          
          if (sheetName === 'DATA_MURID_BACKUP') {
            // Cari timestamp di konten sheet
            const data = sheet.getDataRange().getValues();
            for (let i = 0; i < Math.min(5, data.length); i++) {
              for (let j = 0; j < data[i].length; j++) {
                if (data[i][j] && data[i][j].toString().includes('BACKUP TIMESTAMP:')) {
                  const timestampStr = data[i][j + 1];
                  if (timestampStr) {
                    timestamp = new Date(timestampStr);
                  }
                }
              }
            }
          } else if (sheetName.startsWith('BACKUP_')) {
            // Parse dari nama sheet (format: BACKUP_yyyyMMdd_HHmmss)
            const dateStr = sheetName.split('_')[1];
            if (dateStr && dateStr.length >= 8) {
              const year = dateStr.substring(0, 4);
              const month = dateStr.substring(4, 6);
              const day = dateStr.substring(6, 8);
              timestamp = new Date(`${year}-${month}-${day}`);
            }
          }
          
          backupSheets.push({
            name: sheetName,
            sheet: sheet,
            timestamp: timestamp,
            timestampStr: timestamp.toLocaleString()
          });
          
        } catch (e) {
          console.log(`‚ö†Ô∏è Tidak bisa parse tanggal untuk ${sheetName}: ${e}`);
        }
      }
    });
    
    // Urutkan berdasarkan tanggal (terbaru pertama)
    backupSheets.sort((a, b) => b.timestamp - a.timestamp);
    
    console.log(`üìä Ditemukan ${backupSheets.length} backup sheets`);
    
    // Hapus backup lama jika melebihi maxBackups
    let deletedCount = 0;
    if (backupSheets.length > maxBackups) {
      const toDelete = backupSheets.slice(maxBackups);
      
      toDelete.forEach(backup => {
        try {
          spreadsheet.deleteSheet(backup.sheet);
          console.log(`üóëÔ∏è Hapus backup lama: ${backup.name} (${backup.timestampStr})`);
          deletedCount++;
        } catch (e) {
          console.log(`‚ùå Gagal hapus ${backup.name}: ${e}`);
        }
      });
    }
    
    return {
      total: backupSheets.length,
      deleted: deletedCount,
      kept: Math.min(backupSheets.length, maxBackups),
      currentBackups: backupSheets.slice(0, Math.min(backupSheets.length, maxBackups))
    };
    
  } catch (error) {
    console.error(`‚ùå Cleanup backup gagal: ${error.toString()}`);
    return { error: error.toString() };
  }
}

function setBackupSettings() {
  const ui = SpreadsheetApp.getUi();
  const result = ui.prompt(
    'Atur Jumlah Backup',
    'Masukkan jumlah maksimal backup yang ingin disimpan (default: 3):',
    ui.ButtonSet.OK_CANCEL
  );
  
  if (result.getSelectedButton() === ui.Button.OK) {
    const maxBackups = parseInt(result.getResponseText()) || 3;
    PropertiesService.getScriptProperties().setProperty('MAX_BACKUPS', maxBackups.toString());
    
    const cleanupResult = cleanupOldBackupSheets(maxBackups);
    
    ui.alert(
      'Pengaturan Disimpan',
      `Maksimal ${maxBackups} backup akan disimpan.\n\n` +
      `Status:\n` +
      `‚Ä¢ Backup saat ini: ${cleanupResult.total}\n` +
      `‚Ä¢ Dihapus: ${cleanupResult.deleted}\n` +
      `‚Ä¢ Disimpan: ${cleanupResult.kept}`,
      ui.ButtonSet.OK
    );
  }
}

function backupDataMuridEfisien() {
  try {
    console.log('üíæ Membuat/memperbarui backup efisien...');
    
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const muridSheet = spreadsheet.getSheetByName('Data_Murid');
    
    if (!muridSheet) {
      return { success: false, error: 'Sheet Data_Murid tidak ditemukan' };
    }
    
    const dataCount = muridSheet.getLastRow() - 1;
    
    // HAPUS backup lama jika ada
    let backupSheet = spreadsheet.getSheetByName('DATA_MURID_BACKUP');
    if (backupSheet) {
      spreadsheet.deleteSheet(backupSheet);
      console.log('üóëÔ∏è Backup lama dihapus');
    }
    
    // BUAT backup baru
    backupSheet = spreadsheet.insertSheet('DATA_MURID_BACKUP');
    backupSheet.hideSheet(); // Sembunyikan agar tidak menggangu
    
    // Salin data
    muridSheet.getDataRange().copyTo(backupSheet.getRange(1, 1));
    
    // Tambahkan metadata
    const timestamp = new Date().toLocaleString();
    const lastCol = muridSheet.getLastColumn();
    
    backupSheet.getRange(1, lastCol + 2).setValue('üîê BACKUP TIMESTAMP:');
    backupSheet.getRange(1, lastCol + 3).setValue(timestamp);
    backupSheet.getRange(2, lastCol + 2).setValue('üìä TOTAL DATA:');
    backupSheet.getRange(2, lastCol + 3).setValue(dataCount);
    
    console.log(`‚úÖ Backup diperbarui: ${dataCount} data tersimpan`);
    
    return {
      success: true,
      backupSheet: 'DATA_MURID_BACKUP',
      dataCount: dataCount,
      timestamp: timestamp,
      action: 'UPDATED' // Menandakan bahwa backup diperbarui, bukan dibuat baru
    };
    
  } catch (error) {
    console.error(`‚ùå Backup efisien gagal: ${error.toString()}`);
    return { success: false, error: error.toString() };
  }
}

function restoreDataMuridDariBackup() {
  try {
    console.log('üîÑ Restore data dari backup...');
    
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const backupSheet = spreadsheet.getSheetByName('DATA_MURID_BACKUP');
    
    if (!backupSheet) {
      throw new Error('Backup tidak ditemukan! Jalankan backup terlebih dahulu.');
    }
    
    const muridSheet = spreadsheet.getSheetByName('Data_Murid');
    if (!muridSheet) {
      throw new Error('Sheet Data_Murid tidak ditemukan');
    }
    
    // Ambil data dari backup (hanya data utama, bukan metadata)
    const backupData = backupSheet.getDataRange().getValues();
    const lastDataColumn = muridSheet.getLastColumn();
    
    // Hanya copy data utama (tidak termasuk kolom timestamp backup)
    const dataToRestore = backupData.map(row => row.slice(0, lastDataColumn));
    
    // Clear data lama dan masukkan data backup
    muridSheet.clear();
    muridSheet.getRange(1, 1, dataToRestore.length, lastDataColumn).setValues(dataToRestore);
    
    console.log(`‚úÖ Restore berhasil: ${dataToRestore.length - 1} data dipulihkan`);
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `‚úÖ ${dataToRestore.length - 1} data berhasil direstore dari backup`,
      'Restore Success',
      5
    );
    
    return {
      success: true,
      restoredCount: dataToRestore.length - 1
    };
    
  } catch (error) {
    console.error(`‚ùå Restore gagal: ${error.toString()}`);
    SpreadsheetApp.getActiveSpreadsheet().toast(`‚ùå Restore gagal: ${error.message}`, 'Error', 10);
    return { success: false, error: error.toString() };
  }
}

function syncDataMuridDenganBackup() {
  try {
    console.log('üîÑ Memulai sync dengan backup otomatis...');
    
    // 1. Buat backup dulu
    const backupResult = backupDataMuridEfisien();
    
    if (!backupResult.success) {
      console.log('‚ö†Ô∏è Backup gagal, tapi sync tetap dilanjutkan');
    }
    
    // 2. Jalankan sync seperti biasa
    const syncResult = syncDataMuridWithNotesEnhancedAman();
    
    console.log(`üìä Hasil: ${syncResult}`);
    
    // 3. Tampilkan status backup
    if (backupResult.success) {
      SpreadsheetApp.getActiveSpreadsheet().toast(
        `Sync selesai! Backup dibuat: ${backupResult.dataCount} data`,
        '‚úÖ Sync dengan Backup',
        5
      );
    }
    
    return {
      backup: backupResult,
      sync: syncResult
    };
    
  } catch (error) {
    console.error(`‚ùå Sync dengan backup gagal: ${error.toString()}`);
    return { success: false, error: error.toString() };
  }
}

function cekStatusBackup() {
  try {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const backupSheet = spreadsheet.getSheetByName('DATA_MURID_BACKUP');
    
    if (!backupSheet) {
      return {
        exists: false,
        message: '‚ùå Tidak ada backup tersimpan'
      };
    }
    
    // Cari timestamp di sheet backup
    const backupData = backupSheet.getDataRange().getValues();
    let timestamp = 'Tidak diketahui';
    let dataCount = 0;
    
    // Cari metadata backup (biasanya di kolom terakhir)
    for (let i = 0; i < Math.min(5, backupData.length); i++) {
      for (let j = 0; j < backupData[i].length; j++) {
        if (backupData[i][j] && backupData[i][j].toString().includes('BACKUP TIMESTAMP:')) {
          timestamp = backupData[i][j + 1] || 'Tidak diketahui';
        }
        if (backupData[i][j] && backupData[i][j].toString().includes('TOTAL DATA:')) {
          dataCount = backupData[i][j + 1] || 0;
        }
      }
    }
    
    const result = {
      exists: true,
      timestamp: timestamp,
      dataCount: dataCount,
      message: `‚úÖ Backup tersedia: ${dataCount} data (${timestamp})`
    };
    
    console.log(result.message);
    
    const ui = SpreadsheetApp.getUi();
    ui.alert(
      'üîê STATUS BACKUP DATA_MURID',
      `Status Backup:\n\n` +
      `üìä Data tersimpan: ${dataCount} data\n` +
      `üïê Timestamp: ${timestamp}\n` +
      `üìÅ Lokasi: Sheet "DATA_MURID_BACKUP" (tersembunyi)\n\n` +
      `Gunakan "Restore Data dari Backup" jika perlu mengembalikan data.`,
      ui.ButtonSet.OK
    );
    
    return result;
    
  } catch (error) {
    console.error(`‚ùå Cek status backup gagal: ${error.toString()}`);
    return { exists: false, error: error.toString() };
  }
}

function hapusBackupLama() {
  try {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const backupSheet = spreadsheet.getSheetByName('DATA_MURID_BACKUP');
    
    if (backupSheet) {
      spreadsheet.deleteSheet(backupSheet);
      console.log('üóëÔ∏è Backup lama dihapus');
      return { success: true, message: 'Backup lama dihapus' };
    }
    
    return { success: false, message: 'Tidak ada backup untuk dihapus' };
    
  } catch (error) {
    console.error(`‚ùå Hapus backup gagal: ${error.toString()}`);
    return { success: false, error: error.toString() };
  }
}

// =============================================
// 11. FUNGSI AUTO SYNC & SCHEDULED
// =============================================
function autoSyncScheduled() {
  try {
    Logger.log('üïê AUTO SYNC: Memulai sinkronisasi otomatis...');
    
    nonaktifkanEditTrigger();
    
    const syncResults = [];
    const syncFunctions = [
      { name: 'Data_Guru', func: syncSingleTableFinal, endpoint: 'get_guru' },
      { name: 'Data_Murid', func: syncSingleTableFinal, endpoint: 'get_murid' },
      { name: 'Data_Users', func: syncSingleTableFinal, endpoint: 'get_users' },
      { name: 'Data_Alumni', func: syncSingleTableFinal, endpoint: 'get_alumni' }
    ];
    
    for (const task of syncFunctions) {
      try {
        Logger.log(`üîÑ AUTO SYNC: Processing ${task.name}...`);
        
        const result = task.func(task.name);
        syncResults.push(result);
        
        Logger.log(`‚úÖ AUTO SYNC: ${task.name} - ${result}`);
        Utilities.sleep(2000);
        
      } catch (error) {
        syncResults.push(`‚ùå AUTO SYNC: ${task.name} - ${error.toString()}`);
        Logger.log(`‚ö†Ô∏è AUTO SYNC Error ${task.name}: ${error.toString()}`);
      }
    }
    
    setupEditTrigger();
    
    const successCount = syncResults.filter(r => r.includes('SUCCESS')).length;
    const message = `üïê AUTO SYNC: ${successCount}/${syncFunctions.length} berhasil (${new Date().toLocaleTimeString()})`;
    
    Logger.log(message);
    
    return {
      success: successCount === syncFunctions.length,
      results: syncResults,
      timestamp: new Date().toISOString()
    };
    
  } catch (error) {
    Logger.log(`‚ùå AUTO SYNC Gagal: ${error.toString()}`);
    return { success: false, error: error.toString() };
  }
}

function autoPushScheduled() {
  try {
    Logger.log('üïê AUTO PUSH: Memulai push otomatis...');
    
    const backupResult = backupDataBeforePush();
    if (!backupResult.success) {
      Logger.log('‚ö†Ô∏è AUTO PUSH: Backup gagal, push dilanjutkan');
    }
    
    const pushResult = pushAllDataOptimized();
    
    const successRate = pushResult.analytics?.successRate || 0;
    const message = `üïê AUTO PUSH: ${successRate}% sukses (${new Date().toLocaleTimeString()})`;
    
    Logger.log(message);
    
    return {
      backup: backupResult,
      push: pushResult,
      timestamp: new Date().toISOString()
    };
    
  } catch (error) {
    Logger.log(`‚ùå AUTO PUSH Gagal: ${error.toString()}`);
    return { success: false, error: error.toString() };
  }
}

function autoHealthCheck() {
  const report = detailedSystemHealthCheck();
  
  // Kirim email jika ada masalah kritis
  if (report.issues && report.issues.some(issue => issue.severity === 'HIGH')) {
    sendHealthAlertEmail(report);
  }
}

function quickAutoSync() {
  try {
    Logger.log('‚ö° QUICK AUTO SYNC: Memulai sinkronisasi cepat...');
    
    // Hanya sync data guru dan murid (prioritas tinggi)
    const results = [];
    
    const quickTasks = [
      { name: 'Data_Guru', func: syncSingleTableFinal },
      { name: 'Data_Murid', func: syncSingleTableFinal }
    ];
    
    for (const task of quickTasks) {
      try {
        const result = task.func(task.name);
        results.push(`${task.name}: ${result.includes('SUCCESS') ? '‚úÖ' : '‚ùå'}`);
        Utilities.sleep(1000);
      } catch (error) {
        results.push(`${task.name}: ‚ùå ${error.toString()}`);
      }
    }
    
    Logger.log(`‚ö° QUICK AUTO SYNC selesai: ${results.join(', ')}`);
    
    return {
      success: true,
      results: results,
      timestamp: new Date().toISOString()
    };
    
  } catch (error) {
    Logger.log(`‚ùå Quick auto sync gagal: ${error.toString()}`);
    return { success: false, error: error.toString() };
  }
}

// =============================================
// 12. FUNGSI ANALITIK & REPORTING
// =============================================
function calculatePushAnalytics(results) {
  const analytics = {
    totalSheets: results.length,
    totalRecords: 0,
    successRate: 0,
    averageSuccessPerSheet: 0,
    performance: ''
  };
  
  let totalSuccess = 0;
  let totalProcessed = 0;
  
  results.forEach(result => {
    totalSuccess += result.successCount || 0;
    totalProcessed += (result.successCount || 0) + (result.errorCount || 0) + (result.skippedCount || 0);
  });
  
  analytics.totalRecords = totalProcessed;
  analytics.successRate = totalProcessed > 0 ? Math.round((totalSuccess / totalProcessed) * 100) : 0;
  analytics.averageSuccessPerSheet = results.length > 0 ? Math.round(totalSuccess / results.length) : 0;
  
  if (analytics.successRate >= 95) {
    analytics.performance = 'Excellent üèÜ';
  } else if (analytics.successRate >= 85) {
    analytics.performance = 'Good üëç';
  } else if (analytics.successRate >= 70) {
    analytics.performance = 'Fair ‚ö†Ô∏è';
  } else {
    analytics.performance = 'Needs Improvement ‚ùå';
  }
  
  return analytics;
}

function showPushAnalytics(results, analytics) {
  let message = `üìä **PUSH DATA ANALYTICS**\n\n`;
  message += `üìà **Performance**: ${analytics.performance}\n`;
  message += `‚úÖ **Success Rate**: ${analytics.successRate}%\n`;
  message += `üìã **Total Sheets**: ${analytics.totalSheets}\n`;
  message += `üî¢ **Total Records**: ${analytics.totalRecords}\n\n`;
  
  message += `**DETAIL PER SHEET:**\n`;
  results.forEach(result => {
    const successRate = result.totalProcessed > 0 ? 
      Math.round((result.successCount / result.totalProcessed) * 100) : 0;
    
    message += `‚Ä¢ ${result.sheet}: ${result.successCount}‚úÖ ${result.errorCount}‚ùå ${result.skippedCount}‚è© (${successRate}%)\n`;
  });
  
  // Tampilkan di toast
  SpreadsheetApp.getActiveSpreadsheet().toast(
    message,
    'üìä Push Data Analytics',
    15
  );
  
  // Juga tampilkan di log
  Logger.log(message);
}

function showDetailedPushReport(results, analytics) {
  const ui = SpreadsheetApp.getUi();
  
  let message = `üìä **PUSH DATA DETAILED REPORT**\n\n`;
  message += `‚úÖ **Success Rate**: ${analytics.successRate}%\n`;
  message += `üìà **Total Processed**: ${analytics.totalSuccess + analytics.totalErrors + analytics.totalSkipped}\n`;
  message += `üéØ **Success**: ${analytics.totalSuccess}\n`;
  message += `‚ùå **Errors**: ${analytics.totalErrors}\n`;
  message += `‚è© **Skipped**: ${analytics.totalSkipped}\n\n`;
  
  message += `**DETAIL PER SHEET:**\n`;
  results.forEach(result => {
    const successRate = result.totalProcessed > 0 ? 
      Math.round((result.successCount / result.totalProcessed) * 100) : 0;
    
    message += `‚Ä¢ ${result.sheet} (${result.approach}): ${result.successCount}‚úÖ ${result.errorCount}‚ùå ${result.skippedCount}‚è© (${successRate}%)\n`;
  });
  
  // Rekomendasi berdasarkan hasil
  if (analytics.successRate < 70) {
    message += `\n‚ö†Ô∏è **REKOMENDASI:**\n`;
    message += `‚Ä¢ Periksa koneksi database\n`;
    message += `‚Ä¢ Validasi struktur data di sheets\n`;
    message += `‚Ä¢ Gunakan "Push Data Debug" untuk diagnosa detail\n`;
  }
  
  ui.alert('Push Data Report', message, ui.ButtonSet.OK);
  
  // Juga tampilkan toast notifikasi
  SpreadsheetApp.getActiveSpreadsheet().toast(
    `Push selesai: ${analytics.successRate}% berhasil`,
    'Push Data Report',
    8
  );
}

function showStructureAwareReport(results, structureInfo, analytics) {
  const ui = SpreadsheetApp.getUi();
  
  let message = `üèóÔ∏è **STRUCTURE-AWARE PUSH REPORT**\n\n`;
  message += `üìä **Success Rate**: ${analytics.successRate}%\n`;
  message += `‚úÖ **Success**: ${analytics.totalSuccess}\n`;
  message += `‚ùå **Errors**: ${analytics.totalErrors}\n`;
  message += `‚è© **Skipped**: ${analytics.totalSkipped}\n\n`;
  
  message += `**STRUCTURE ANALYSIS:**\n`;
  for (const [sheetName, info] of Object.entries(structureInfo)) {
    if (info) {
      const invalidCount = info.invalidColumns ? info.invalidColumns.length : 0;
      message += `‚Ä¢ ${sheetName}: ${invalidCount} kolom invalid\n`;
    }
  }
  
  message += `\n**DETAIL RESULTS:**\n`;
  results.forEach(result => {
    const successRate = result.totalProcessed > 0 ? 
      Math.round((result.successCount / result.totalProcessed) * 100) : 0;
    
    message += `‚Ä¢ ${result.sheet}: ${result.successCount}‚úÖ ${result.errorCount}‚ùå ${result.skippedCount}‚è© (${successRate}%)\n`;
  });
  
  // Rekomendasi
  message += `\nüí° **REKOMENDASI:**\n`;
  
  const hasStructureErrors = Object.values(structureInfo).some(info => 
    info && info.invalidColumns && info.invalidColumns.length > 0
  );
  
  if (hasStructureErrors) {
    message += `‚Ä¢ ‚ùå Ada ketidaksesuaian struktur database\n`;
    message += `‚Ä¢ üîß Gunakan "Diagnosa Struktur Database"\n`;
    message += `‚Ä¢ üìù Sesuaikan kolom di sheets dengan database\n`;
  }
  
  if (analytics.successRate < 80) {
    message += `‚Ä¢ ‚ö†Ô∏è Success rate rendah, periksa log untuk detail\n`;
  }
  
  ui.alert('Structure-Aware Push Report', message, ui.ButtonSet.OK);
  
  // Toast notification
  SpreadsheetApp.getActiveSpreadsheet().toast(
    `Push selesai: ${analytics.successRate}% berhasil`,
    'Structure-Aware Push',
    8
  );
}

function showDirectPushReport(results, analytics) {
  const sheet = buatSummarySheet();
  sheet.clear();
  
  let row = 1;
  sheet.getRange(row, 1).setValue('‚ö° DIRECT PUSH DATA REPORT').setFontWeight("bold").setFontSize(16);
  row++;
  sheet.getRange(row, 1).setValue(`Timestamp: ${new Date().toLocaleString()}`);
  row++;
  sheet.getRange(row, 1).setValue(`Success Rate: ${analytics.successRate}%`);
  row++;
  sheet.getRange(row, 1).setValue(`Total Processed: ${analytics.totalSuccess + analytics.totalErrors + analytics.totalSkipped}`);
  row++;
  sheet.getRange(row, 1).setValue(`Success: ${analytics.totalSuccess} ‚úÖ`);
  row++;
  sheet.getRange(row, 1).setValue(`Errors: ${analytics.totalErrors} ‚ùå`);
  row++;
  sheet.getRange(row, 1).setValue(`Skipped: ${analytics.totalSkipped} ‚è©`);
  row++;
  row++;
  
  sheet.getRange(row, 1).setValue('DETAIL PER SHEET:').setFontWeight("bold");
  row++;
  
  results.forEach(result => {
    const successRate = (result.successCount + result.errorCount + result.skippedCount) > 0 ? 
      Math.round((result.successCount / (result.successCount + result.errorCount + result.skippedCount)) * 100) : 0;
    
    sheet.getRange(row, 1).setValue(`${result.sheet}: ${result.successCount}‚úÖ ${result.errorCount}‚ùå ${result.skippedCount}‚è© (${successRate}%)`);
    row++;
  });
  
  // Auto resize
  sheet.autoResizeColumn(1);
  
  // Toast notification
  const toastMsg = analytics.successRate === 100 ? 
    `üéâ Push sukses 100%! ${analytics.totalSuccess} data tersinkronisasi` :
    `Push selesai: ${analytics.successRate}% berhasil`;
    
  SpreadsheetApp.getActiveSpreadsheet().toast(toastMsg, '‚ö° Direct Push', 8);
  
  Logger.log('üìä Direct Push Report telah ditulis ke sheet SUMMARY');
}

function showFlexiblePushReport(results, analytics) {
  const sheet = buatSummarySheet();
  sheet.clear();
  
  let row = 1;
  sheet.getRange(row, 1).setValue('üîÑ FLEXIBLE PUSH DATA REPORT').setFontWeight("bold").setFontSize(16);
  row++;
  sheet.getRange(row, 1).setValue(`Timestamp: ${new Date().toLocaleString()}`);
  row++;
  sheet.getRange(row, 1).setValue(`Success Rate: ${analytics.successRate}%`);
  row++;
  sheet.getRange(row, 1).setValue(`Total Processed: ${analytics.totalSuccess + analytics.totalErrors + analytics.totalSkipped}`);
  row++;
  sheet.getRange(row, 1).setValue(`Success: ${analytics.totalSuccess} ‚úÖ`);
  row++;
  sheet.getRange(row, 1).setValue(`Errors: ${analytics.totalErrors} ‚ùå`);
  row++;
  sheet.getRange(row, 1).setValue(`Skipped: ${analytics.totalSkipped} ‚è©`);
  row++;
  row++;
  
  sheet.getRange(row, 1).setValue('DETAIL PER SHEET:').setFontWeight("bold");
  row++;
  
  results.forEach(result => {
    const total = (result.successCount || 0) + (result.errorCount || 0) + (result.skippedCount || 0);
    const rate = total > 0 ? Math.round((result.successCount / total) * 100) : 0;
    
    sheet.getRange(row, 1).setValue(`${result.sheet}: ${result.successCount}‚úÖ ${result.errorCount}‚ùå ${result.skippedCount}‚è© (${rate}%)`);
    row++;
  });
  
  // Rekomendasi
  row++;
  sheet.getRange(row, 1).setValue('üí° REKOMENDASI:').setFontWeight("bold");
  row++;
  
  if (analytics.successRate === 100) {
    sheet.getRange(row, 1).setValue('‚Ä¢ ‚úÖ Sistem bekerja sempurna! Lanjutkan dengan push semua data');
    row++;
    sheet.getRange(row, 1).setValue('‚Ä¢ üöÄ Gunakan "Push All Data Direct" untuk sinkronisasi lengkap');
  } else if (analytics.successRate >= 80) {
    sheet.getRange(row, 1).setValue('‚Ä¢ üëç Performance baik, bisa lanjut push semua data');
    row++;
    sheet.getRange(row, 1).setValue('‚Ä¢ ‚ö° Error kecil bisa diabaikan');
  } else {
    sheet.getRange(row, 1).setValue('‚Ä¢ üîß Ada masalah, periksa log untuk detail error');
    row++;
    sheet.getRange(row, 1).setValue('‚Ä¢ üìù Fokus perbaikan pada sheet dengan error terbanyak');
  }
  
  sheet.autoResizeColumn(1);
  
  // Toast notification
  const toastMsg = analytics.successRate === 100 ? 
    `üéâ Push fleksibel sukses 100%!` :
    `Push fleksibel selesai: ${analytics.successRate}% berhasil`;
    
  SpreadsheetApp.getActiveSpreadsheet().toast(toastMsg, 'Flexible Push', 8);
}

function showMappingPushReport(results, analytics) {
  const sheet = buatSummarySheet();
  sheet.clear();
  
  let row = 1;
  sheet.getRange(row, 1).setValue('üîÑ PUSH WITH MAPPING REPORT').setFontWeight("bold").setFontSize(16);
  row++;
  sheet.getRange(row, 1).setValue(`Timestamp: ${new Date().toLocaleString()}`);
  row++;
  sheet.getRange(row, 1).setValue(`Success Rate: ${analytics.successRate}%`);
  row++;
  sheet.getRange(row, 1).setValue(`Total Processed: ${analytics.totalSuccess + analytics.totalErrors + analytics.totalSkipped}`);
  row++;
  sheet.getRange(row, 1).setValue(`Success: ${analytics.totalSuccess} ‚úÖ`);
  row++;
  sheet.getRange(row, 1).setValue(`Errors: ${analytics.totalErrors} ‚ùå`);
  row++;
  sheet.getRange(row, 1).setValue(`Skipped: ${analytics.totalSkipped} ‚è©`);
  row++;
  row++;
  
  sheet.getRange(row, 1).setValue('DETAIL PER SHEET:').setFontWeight("bold");
  row++;
  
  results.forEach(result => {
    const total = (result.successCount || 0) + (result.errorCount || 0) + (result.skippedCount || 0);
    const rate = total > 0 ? Math.round((result.successCount / total) * 100) : 0;
    
    sheet.getRange(row, 1).setValue(`${result.sheet}: ${result.successCount}‚úÖ ${result.errorCount}‚ùå ${result.skippedCount}‚è© (${rate}%)`);
    row++;
  });
  
  sheet.autoResizeColumn(1);
  
  const toastMsg = analytics.successRate === 100 ? 
    `üéâ Push with mapping sukses 100%!` :
    `Push mapping selesai: ${analytics.successRate}% berhasil`;
    
  SpreadsheetApp.getActiveSpreadsheet().toast(toastMsg, 'Push Mapping', 8);
}

function showPushValidationReport(results, analytics) {
  const sheet = buatSummarySheet();
  sheet.clear();
  
  let row = 1;
  sheet.getRange(row, 1).setValue('üõ°Ô∏è PUSH DATA VALIDATION REPORT').setFontWeight("bold").setFontSize(16);
  row += 2;
  
  sheet.getRange(row, 1).setValue(`Status: ${analytics.successRate === 100 ? 'üéâ BERHASIL' : analytics.successRate >= 50 ? '‚ö†Ô∏è SEBAGIAN BERHASIL' : '‚ùå GAGAL'}`);
  row++;
  sheet.getRange(row, 1).setValue(`Success Rate: ${analytics.successRate}%`);
  row++;
  sheet.getRange(row, 1).setValue(`Total Processed: ${analytics.totalSuccess + analytics.totalErrors + analytics.totalSkipped}`);
  row++;
  sheet.getRange(row, 1).setValue(`Success: ${analytics.totalSuccess} ‚úÖ`);
  row++;
  sheet.getRange(row, 1).setValue(`Errors: ${analytics.totalErrors} ‚ùå`);
  row++;
  sheet.getRange(row, 1).setValue(`Skipped: ${analytics.totalSkipped} ‚è©`);
  row += 2;
  
  sheet.getRange(row, 1).setValue('DETAIL PER SHEET:').setFontWeight("bold");
  row++;
  
  results.forEach(result => {
    const total = (result.successCount || 0) + (result.errorCount || 0) + (result.skippedCount || 0);
    const rate = total > 0 ? Math.round((result.successCount / total) * 100) : 0;
    
    sheet.getRange(row, 1).setValue(`${result.sheet}: ${result.successCount}‚úÖ ${result.errorCount}‚ùå ${result.skippedCount}‚è© (${rate}%)`);
    row++;
  });
  
  row += 2;
  sheet.getRange(row, 1).setValue('üí° REKOMENDASI:').setFontWeight("bold");
  row++;
  
  if (analytics.successRate === 100) {
    sheet.getRange(row, 1).setValue('‚Ä¢ ‚úÖ Sistem bekerja sempurna! Bisa push semua data');
    row++;
    sheet.getRange(row, 1).setValue('‚Ä¢ üöÄ Lanjutkan dengan push data lengkap');
  } else if (analytics.successRate >= 70) {
    sheet.getRange(row, 1).setValue('‚Ä¢ üëç Performance baik, ada sedikit error yang bisa diabaikan');
    row++;
    sheet.getRange(row, 1).setValue('‚Ä¢ ‚ö° Bisa lanjut push data lengkap');
  } else {
    sheet.getRange(row, 1).setValue('‚Ä¢ üîß Masih ada masalah struktur, perbaiki dulu');
    row++;
    sheet.getRange(row, 1).setValue('‚Ä¢ üìù Check log untuk detail error');
  }
  
  sheet.autoResizeColumn(1);
}

function showOptimizedPushReport(results, analytics) {
  const sheet = buatSummarySheet();
  sheet.clear();
  
  let row = 1;
  sheet.getRange(row, 1).setValue('‚ö° OPTIMIZED PUSH DATA REPORT').setFontWeight("bold").setFontSize(16);
  row++;
  sheet.getRange(row, 1).setValue(`Timestamp: ${new Date().toLocaleString()}`);
  row++;
  sheet.getRange(row, 1).setValue(`Success Rate: ${analytics.successRate}%`);
  row++;
  sheet.getRange(row, 1).setValue(`Total Processed: ${analytics.totalSuccess + analytics.totalErrors + analytics.totalSkipped}`);
  row++;
  sheet.getRange(row, 1).setValue(`Success: ${analytics.totalSuccess} ‚úÖ`);
  row++;
  sheet.getRange(row, 1).setValue(`Errors: ${analytics.totalErrors} ‚ùå`);
  row++;
  sheet.getRange(row, 1).setValue(`Skipped: ${analytics.totalSkipped} ‚è©`);
  row++;
  row++;
  
  sheet.getRange(row, 1).setValue('DETAIL PER SHEET:').setFontWeight("bold");
  row++;
  
  results.forEach(result => {
    const successRate = result.totalProcessed > 0 ? 
      Math.round((result.successCount / result.totalProcessed) * 100) : 0;
    
    sheet.getRange(row, 1).setValue(`${result.sheet}: ${result.successCount}‚úÖ ${result.errorCount}‚ùå ${result.skippedCount}‚è© (${successRate}%)`);
    row++;
  });
  
  // Performance recommendation
  row++;
  sheet.getRange(row, 1).setValue('üí° PERFORMANCE INSIGHT:').setFontWeight("bold");
  row++;
  
  if (analytics.successRate === 100) {
    sheet.getRange(row, 1).setValue('‚Ä¢ ‚úÖ Excellent! Sistem bekerja sempurna');
    row++;
    sheet.getRange(row, 1).setValue('‚Ä¢ üöÄ Lanjutkan dengan approach ini untuk semua sheet');
    row++;
  } else if (analytics.successRate >= 90) {
    sheet.getRange(row, 1).setValue('‚Ä¢ üëç Performance sangat baik');
    row++;
    sheet.getRange(row, 1).setValue('‚Ä¢ ‚ö° Approach optimized recommended untuk production');
    row++;
  } else {
    sheet.getRange(row, 1).setValue('‚Ä¢ üîß Beberapa error terdeteksi, check log untuk detail');
    row++;
  }
  
  // Auto resize
  sheet.autoResizeColumn(1);
  
  // Toast notification
  const toastMsg = analytics.successRate === 100 ? 
    `üéâ Push sukses 100%! ${analytics.totalSuccess} data tersinkronisasi` :
    `Push selesai: ${analytics.successRate}% berhasil`;
    
  SpreadsheetApp.getActiveSpreadsheet().toast(toastMsg, '‚ö° Optimized Push', 8);
  
  Logger.log('üìä Optimized Push Report telah ditulis ke sheet SUMMARY');
}

function writeResultsToSummary(results) {
  try {
    const sheet = buatSummarySheet();
    sheet.clear();
    
    let row = 1;
    sheet.getRange(row, 1).setValue('üìä HASIL PUSH DATA OPTIMIZED').setFontWeight("bold").setFontSize(16);
    row++;
    sheet.getRange(row, 1).setValue(`Timestamp: ${new Date().toLocaleString()}`);
    row++;
    sheet.getRange(row, 1).setValue(`Success: ${results.success} ‚úÖ`);
    row++;
    sheet.getRange(row, 1).setValue(`Failed: ${results.failed} ‚ùå`);
    row++;
    sheet.getRange(row, 1).setValue(`Skipped: ${results.skipped} ‚è©`);
    row++;
    
    const total = results.success + results.failed + results.skipped;
    const successRate = total > 0 ? Math.round((results.success / total) * 100) : 0;
    
    sheet.getRange(row, 1).setValue(`Success Rate: ${successRate}%`);
    row++;
    
    sheet.autoResizeColumn(1);
    
    console.log(`üìä Results written to SUMMARY: ${successRate}% success`);
    
  } catch (error) {
    console.error(`‚ùå Error writing results: ${error.toString()}`);
  }
}

function tampilkanSummary(results) {
  const sheet = buatSummarySheet();
  sheet.clear();
  
  sheet.getRange('A1').setValue('üìä SISTEM SINKRONISASI DATABASE PPMA').setFontWeight("bold").setFontSize(16);
  sheet.getRange('A2').setValue('Last Update: ' + new Date().toLocaleString()).setFontColor('#666666');
  sheet.getRange('A3').setValue('‚ûñ'.repeat(25));
  sheet.getRange('A4').setValue('üîó STATUS KONEKSI API').setFontWeight("bold").setFontSize(12);
  sheet.getRange('A5').setValue('‚úÖ Terhubung dengan database MySQL').setFontColor('#4CAF50');
  sheet.getRange('A7').setValue('üìà SUMMARY DATA TERKINI').setFontWeight("bold").setFontSize(12);
  
  let row = 8;
  results.forEach((result) => {
    if (result && typeof result === 'string') {
      const cleanResult = result.replace(/[#=+@-]/g, '').trim();
      if (cleanResult) {
        sheet.getRange(`A${row}`).setValue(`‚Ä¢ ${cleanResult}`);
        row++;
      }
    }
  });
  
  sheet.getRange(`A${row + 1}`).setValue('üí° INFORMASI:').setFontWeight("bold");
  sheet.getRange(`A${row + 2}`).setValue('- Data diupdate otomatis dari database MySQL');
  sheet.getRange(`A${row + 3}`).setValue('- Klik "jalankanSinkronisasi" untuk update manual');
  
  sheet.autoResizeColumn(1);
  const dataRange = sheet.getRange('A1:A' + (row + 3));
  dataRange.setVerticalAlignment('top');
}

// =============================================
// 13. FUNGSI HEALTH CHECK & MONITORING
// =============================================
function detailedHealthCheckWithFix() {
  try {
    console.log('üè• Memulai health check detail...');
    
    const healthReport = {
      timestamp: new Date().toLocaleString(),
      checks: [],
      issues: [],
      recommendations: [],
      score: 100 // Default 100, kurangi jika ada masalah
    };
    
    // CHECK 1: API Connection saja
    console.log('üîó Checking API connection...');
    try {
      const apiTest = testAPIConnection();
      const isApiOk = apiTest.includes('SUCCESS');
      healthReport.checks.push({
        name: 'API Connection',
        status: isApiOk ? 'PASS' : 'FAIL',
        details: apiTest
      });
      
      if (!isApiOk) {
        healthReport.score -= 40;
        healthReport.issues.push({
          type: 'API_CONNECTION',
          severity: 'HIGH',
          message: 'Koneksi API bermasalah',
          fix: 'Periksa koneksi internet dan server API'
        });
      }
    } catch (error) {
      healthReport.checks.push({
        name: 'API Connection',
        status: 'ERROR',
        details: error.toString()
      });
      healthReport.score -= 40;
    }
    
    // CHECK 2: Data Sheets (hanya yang penting)
    console.log('üìä Checking data sheets...');
    const requiredSheets = ['Data_Murid', 'Data_Guru'];
    
    requiredSheets.forEach(sheetName => {
      const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
      const status = sheet ? 'EXISTS' : 'MISSING';
      const details = sheet ? `${sheet.getLastRow()-1} rows` : 'Sheet tidak ditemukan';
      
      healthReport.checks.push({
        name: `Sheet: ${sheetName}`,
        status: status,
        details: details
      });
      
      if (!sheet) {
        healthReport.score -= 20;
      }
    });
    
    // Tampilkan report sederhana tanpa rekomendasi fix otomatis
    const sheet = buatSummarySheet();
    sheet.clear();
    
    let row = 1;
    sheet.getRange(row, 1).setValue('üè• HEALTH CHECK REPORT').setFontWeight("bold").setFontSize(16);
    row += 2;
    
    sheet.getRange(row, 1).setValue(`Score: ${healthReport.score}/100`);
    row++;
    sheet.getRange(row, 1).setValue(`${healthReport.checks.filter(c => 
      c.status === 'PASS' || c.status === 'EXISTS'
    ).length}/${healthReport.checks.length} checks passed`);
    row += 2;
    
    sheet.getRange(row, 1).setValue('üìã DETAILED CHECKS:');
    row++;
    
    healthReport.checks.forEach(check => {
      const statusIcon = 
        check.status === 'PASS' || check.status === 'EXISTS' ? '‚úÖ' : '‚ùå';
      
      sheet.getRange(row, 1).setValue(`${statusIcon} ${check.name}: ${check.status} (${check.details})`);
      row++;
    });
    
    sheet.autoResizeColumn(1);
    
    // TIDAK ADA FIX OTOMATIS - hanya informasi
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `Health check selesai: ${healthReport.score}/100`,
      'Health Check',
      5
    );
    
    return healthReport;
    
  } catch (error) {
    console.error(`‚ùå Health check failed: ${error.toString()}`);
    return { error: error.toString() };
  }
}

function displayEnhancedHealthReport(report) {
  const ui = SpreadsheetApp.getUi();
  
  let message = `üè• HEALTH CHECK REPORT\n`;
  message += `‚è∞ ${report.timestamp}\n`;
  message += `üìä Score: ${report.score}/100\n`;
  message += `‚úÖ ${report.checks.filter(c => 
    c.status === 'PASS' || c.status === 'ACTIVE' || c.status === 'EXISTS'
  ).length}/${report.checks.length} checks passed\n\n`;
  
  message += `üìã DETAILED CHECKS:\n`;
  report.checks.forEach(check => {
    const statusIcon = 
      check.status === 'PASS' || check.status === 'ACTIVE' || check.status === 'EXISTS' ? '‚úÖ' :
      check.status === 'INACTIVE' || check.status === 'MISSING' ? '‚ö†Ô∏è' : '‚ùå';
    
    message += `${statusIcon} ${check.name}: ${check.status} (${check.details})\n`;
  });
  
  if (report.issues.length > 0) {
    message += `\n‚ö†Ô∏è ISSUES FOUND (${report.issues.length}):\n`;
    report.issues.forEach(issue => {
      const severityIcon = 
        issue.severity === 'HIGH' ? 'üî¥' :
        issue.severity === 'MEDIUM' ? 'üü°' : 'üîµ';
      
      message += `${severityIcon} ${issue.message}\n`;
      message += `   Fix: ${issue.fix}\n\n`;
    });
  }
  
  if (report.recommendations.length > 0) {
    message += `üí° RECOMMENDATIONS:\n`;
    report.recommendations.forEach(rec => {
      message += `‚Ä¢ ${rec}\n`;
    });
  }
  
  const buttons = report.issues.length > 0 ? 
    SpreadsheetApp.getUi().ButtonSet.YES_NO_CANCEL : 
    SpreadsheetApp.getUi().ButtonSet.OK;
  
  const response = ui.alert(
    'Health Check Report',
    message,
    buttons
  );
  
  if (response === ui.Button.YES) {
    // Jalankan perbaikan otomatis
    fixAllIssues();
  }
}

function monitorLogs() {
  const logSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Realtime_Log');
  const errorSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Error_Log');
  
  let message = 'üìä MONITORING SYSTEM\n\n';
  
  if (logSheet && logSheet.getLastRow() > 1) {
    const lastLog = logSheet.getRange(logSheet.getLastRow(), 1, 1, 5).getValues()[0];
    message += `üîÑ Log Terakhir: ${lastLog[0]}\n`;
    message += `üìù Event: ${lastLog[1]}\n`;
    message += `üìã Sheet: ${lastLog[2]}\n`;
    message += `üìà Row: ${lastLog[3]}\n\n`;
  }
  
  if (errorSheet && errorSheet.getLastRow() > 1) {
    const errorCount = errorSheet.getLastRow() - 1;
    message += `ü©∫ Error Count: ${errorCount}\n`;
    
    if (errorCount > 0) {
      const lastError = errorSheet.getRange(errorSheet.getLastRow(), 1, 1, 6).getValues()[0];
      message += `‚ùå Error Terakhir: ${lastError[2]}\n`;
    }
  }
  
  const triggers = ScriptApp.getProjectTriggers();
  message += `‚ö° Active Triggers: ${triggers.length}\n`;
  
  // --- BAGIAN BARU: Pengecekan Konteks ---
  try {
    // Coba dapatkan UI. Jika gagal, berarti tidak dalam konteks UI.
    const ui = SpreadsheetApp.getActiveSpreadsheet().toast();
    // Jika berhasil, tampilkan dialog alert.
    ui.alert('System Monitor', message, ui.ButtonSet.OK);
  } catch (error) {
    // Jika gagal, log pesan ke konsol.
    console.log('--- System Monitor ---\n' + message);
    console.log('(Dialog tidak ditampilkan - berjalan di konteks non-UI)');
  }
}

function checkSystemHealthOnStartup() {
  try {
    // Delay untuk memastikan spreadsheet selesai loading
    Utilities.sleep(2000);
    
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const summarySheet = spreadsheet.getSheetByName('API, SUMMARY');
    
    if (!summarySheet) {
      return;
    }
    
    // Check jika sudah ada data di summary
    if (summarySheet.getLastRow() < 5) {
      // Run quick check
      quickDataCheck();
    }
    
    // Check edit trigger status
    const hasTrigger = checkEditTrigger();
    if (!hasTrigger) {
      spreadsheet.toast(
        '‚ö†Ô∏è Edit trigger tidak aktif. Klik "‚ö° Activate Edit Trigger"',
        'System Notice',
        8
      );
    }
    
  } catch (error) {
    // Ignore startup errors
    Logger.log(`Startup check error: ${error.toString()}`);
  }
}

function detailedSystemHealthCheck() {
  try {
    console.log('üè• Memulai pemeriksaan kesehatan sistem detail...');
    
    const healthReport = {
      timestamp: new Date().toLocaleString(),
      summary: '',
      statistics: {},
      issues: [],
      recommendations: [],
      recentActivity: [],
      performance: {}
    };
    
    // 1. ANALISIS REALTIME_LOG
    const realtimeLog = analyzeRealtimeLog();
    healthReport.statistics.realtime = realtimeLog;
    
    // 2. ANALISIS ERROR_LOG  
    const errorLog = analyzeErrorLog();
    healthReport.statistics.errors = errorLog;
    
    // 3. CEK TRIGGER & KONEKSI
    const systemStatus = checkSystemComponents();
    healthReport.statistics.system = systemStatus;
    
    // 4. ANALISIS PERFORMANSI
    healthReport.performance = analyzePerformance(realtimeLog);
    
    // 5. DETEKSI MASALAH
    healthReport.issues = detectSystemIssues(
      realtimeLog, 
      errorLog, 
      systemStatus
    );
    
    // 6. BUAT REKOMENDASI
    healthReport.recommendations = generateRecommendations(healthReport);
    
    // 7. AMBIL AKTIVITAS TERBARU
    healthReport.recentActivity = getRecentActivity(10); // 10 aktivitas terbaru
    
    // 8. BUAT SUMMARY
    healthReport.summary = generateHealthSummary(healthReport);
    
    // 9. TAMPILKAN/TAMPILKAN LAPORAN
    displayHealthReport(healthReport);
    
    // 10. SIMPAN LAPORAN KE SHEET
    saveHealthReportToSheet(healthReport);
    
    return healthReport;
    
  } catch (error) {
    console.error(`‚ùå Health check gagal: ${error.toString()}`);
    logErrorDetail('detailedSystemHealthCheck', error);
    return { error: error.toString() };
  }
}

function systemHealthCheck() {
  try {
    return detailedSystemHealthCheck();
  } catch (error) {
    logErrorDetail('systemHealthCheck', error);
    return { error: error.toString() };
  }
}

function detectSystemIssues(realtimeLog, errorLog, systemStatus) {
  const issues = [];
  
  // Issue 1: Low success rate
  if (realtimeLog.successRate < 70) {
    issues.push({
      type: 'LOW_SUCCESS_RATE',
      severity: 'HIGH',
      message: `Success rate rendah: ${realtimeLog.successRate}%`,
      fix: 'Periksa koneksi API dan struktur data'
    });
  }
  
  // Issue 2: High error rate
  if (errorLog.totalErrors > 10 && errorLog.errorsPerDay > 5) {
    issues.push({
      type: 'HIGH_ERROR_RATE',
      severity: 'MEDIUM',
      message: `Tingkat error tinggi: ${errorLog.totalErrors} errors (${errorLog.errorsPerDay}/hari)`,
      fix: 'Analisis error log untuk pola masalah'
    });
  }
  
  // Issue 3: No edit trigger
  if (!systemStatus.hasEditTrigger) {
    issues.push({
      type: 'NO_EDIT_TRIGGER',
      severity: 'MEDIUM',
      message: 'Edit trigger tidak aktif',
      fix: 'Jalankan "Setup Sistem Lengkap" untuk mengaktifkan trigger'
    });
  }
  
  // Issue 4: Low activity
  if (realtimeLog.eventsPerHour < 1 && realtimeLog.totalEntries > 0) {
    issues.push({
      type: 'LOW_ACTIVITY',
      severity: 'LOW',
      message: 'Aktivitas sistem rendah',
      fix: 'Pastikan sistem digunakan secara aktif'
    });
  }
  
  return issues;
}

function generateRecommendations(healthReport) {
  const recommendations = [];
  
  if (healthReport.performance && healthReport.performance.score < 70) {
    recommendations.push('üéØ **Tingkatkan performa sistem** dengan mengoptimasi query API');
  }
  
  if (healthReport.issues && healthReport.issues.some(i => i.severity === 'HIGH')) {
    recommendations.push('üîß **Perbaiki masalah kritis** terlebih dahulu sebelum melanjutkan');
  }
  
  if (healthReport.statistics && healthReport.statistics.errors && healthReport.statistics.errors.totalErrors > 0) {
    recommendations.push('üìù **Analisis error log** untuk mengidentifikasi pola masalah');
  }
  
  if (!healthReport.statistics.system.hasEditTrigger) {
    recommendations.push('‚ö° **Aktifkan edit trigger** untuk sinkronisasi realtime');
  }
  
  recommendations.push('üîÑ **Jalankan sync berkala** untuk menjaga data tetap up-to-date');
  recommendations.push('üìä **Monitor log aktivitas** untuk deteksi dini masalah');
  
  return recommendations;
}

function getRecentActivity(limit = 10) {
  try {
    const logSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Realtime_Log');
    if (!logSheet || logSheet.getLastRow() <= 1) {
      return [];
    }
    
    const data = logSheet.getDataRange().getValues();
    const headers = data[0];
    const logData = data.slice(1).reverse(); // Ambil yang terbaru
    
    const timestampIdx = headers.indexOf('Timestamp');
    const eventTypeIdx = headers.indexOf('Event Type');
    const sheetIdx = headers.indexOf('Sheet');
    const rowIdx = headers.indexOf('Row');
    
    return logData.slice(0, limit).map(row => ({
      timestamp: row[timestampIdx],
      event: row[eventTypeIdx],
      sheet: row[sheetIdx],
      row: row[rowIdx],
      status: row[eventTypeIdx]?.includes('success') ? 'success' : 'error'
    }));
    
  } catch (error) {
    console.error(`‚ùå Error get recent activity: ${error.toString()}`);
    return [];
  }
}

function generateHealthSummary(healthReport) {
  const score = healthReport.performance?.score || 0;
  const totalIssues = healthReport.issues?.length || 0;
  const highIssues = healthReport.issues?.filter(i => i.severity === 'HIGH').length || 0;
  
  let summary = `üè• **SISTEM HEALTH CHECK**\n\n`;
  summary += `‚è∞ ${healthReport.timestamp}\n`;
  summary += `üìä **Score**: ${score}/100\n`;
  summary += `‚ö†Ô∏è **Issues**: ${totalIssues} total, ${highIssues} kritis\n\n`;
  
  if (score >= 90) {
    summary += `üéâ **Status**: EXCELLENT - Sistem berjalan optimal!\n`;
  } else if (score >= 80) {
    summary += `üëç **Status**: GOOD - Sistem berjalan dengan baik\n`;
  } else if (score >= 70) {
    summary += `‚ö†Ô∏è **Status**: FAIR - Perlu perhatian\n`;
  } else if (score >= 60) {
    summary += `üîß **Status**: NEEDS IMPROVEMENT - Perlu perbaikan\n`;
  } else {
    summary += `‚ùå **Status**: POOR - Perlu tindakan segera\n`;
  }
  
  return summary;
}

function displayHealthReport(healthReport) {
  try {
    const ui = SpreadsheetApp.getUi();
    
    let message = healthReport.summary + '\n';
    
    message += `üìà **PERFORMANCE**: ${healthReport.performance?.rating || 'N/A'}\n`;
    message += `‚úÖ **Success Rate**: ${healthReport.statistics?.realtime?.successRate || 0}%\n`;
    message += `‚ùå **Total Errors**: ${healthReport.statistics?.errors?.totalErrors || 0}\n`;
    message += `‚ö° **Active Triggers**: ${healthReport.statistics?.system?.hasEditTrigger ? '‚úÖ' : '‚ùå'}\n\n`;
    
    if (healthReport.issues && healthReport.issues.length > 0) {
      message += `‚ö†Ô∏è **ISSUES DETECTED**:\n`;
      healthReport.issues.forEach(issue => {
        const icon = issue.severity === 'HIGH' ? 'üî¥' : 
                    issue.severity === 'MEDIUM' ? 'üü°' : 'üîµ';
        message += `${icon} ${issue.message}\n`;
      });
      message += `\n`;
    }
    
    if (healthReport.recommendations && healthReport.recommendations.length > 0) {
      message += `üí° **RECOMMENDATIONS**:\n`;
      healthReport.recommendations.forEach(rec => {
        message += `‚Ä¢ ${rec}\n`;
      });
    }
    
    ui.alert('System Health Check Report', message, ui.ButtonSet.OK);
    
  } catch (error) {
    console.error(`‚ùå Error display health report: ${error.toString()}`);
    // Fallback ke toast
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `Health Check: ${healthReport.performance?.score || 0}/100`,
      'Health Report',
      5
    );
  }
}

function saveHealthReportToSheet(healthReport) {
  try {
    const sheet = buatSheet('Health_Report_' + new Date().toISOString().split('T')[0]);
    
    let row = 1;
    sheet.getRange(row, 1).setValue('üè• HEALTH CHECK REPORT').setFontWeight("bold").setFontSize(16);
    row += 2;
    
    sheet.getRange(row, 1).setValue('Timestamp:').setFontWeight("bold");
    sheet.getRange(row, 2).setValue(healthReport.timestamp);
    row++;
    
    sheet.getRange(row, 1).setValue('Overall Score:').setFontWeight("bold");
    sheet.getRange(row, 2).setValue(`${healthReport.performance?.score || 0}/100`);
    row++;
    
    sheet.getRange(row, 1).setValue('Performance Rating:').setFontWeight("bold");
    sheet.getRange(row, 2).setValue(healthReport.performance?.rating || 'N/A');
    row += 2;
    
    // Statistics
    sheet.getRange(row, 1).setValue('üìä STATISTICS').setFontWeight("bold").setFontSize(14);
    row++;
    
    if (healthReport.statistics?.realtime) {
      sheet.getRange(row, 1).setValue('Realtime Log:');
      sheet.getRange(row, 2).setValue(`${healthReport.statistics.realtime.totalEntries} entries`);
      row++;
      
      sheet.getRange(row, 1).setValue('Success Rate:');
      sheet.getRange(row, 2).setValue(`${healthReport.statistics.realtime.successRate}%`);
      row++;
    }
    
    if (healthReport.statistics?.errors) {
      sheet.getRange(row, 1).setValue('Total Errors:');
      sheet.getRange(row, 2).setValue(healthReport.statistics.errors.totalErrors);
      row++;
    }
    
    if (healthReport.statistics?.system) {
      sheet.getRange(row, 1).setValue('Edit Trigger:');
      sheet.getRange(row, 2).setValue(healthReport.statistics.system.hasEditTrigger ? '‚úÖ Active' : '‚ùå Inactive');
      row++;
    }
    
    row += 2;
    
    // Issues
    if (healthReport.issues && healthReport.issues.length > 0) {
      sheet.getRange(row, 1).setValue('‚ö†Ô∏è ISSUES').setFontWeight("bold").setFontSize(14);
      row++;
      
      healthReport.issues.forEach(issue => {
        sheet.getRange(row, 1).setValue(`‚Ä¢ ${issue.type}:`);
        sheet.getRange(row, 2).setValue(issue.message);
        row++;
      });
      
      row += 2;
    }
    
    // Recommendations
    if (healthReport.recommendations && healthReport.recommendations.length > 0) {
      sheet.getRange(row, 1).setValue('üí° RECOMMENDATIONS').setFontWeight("bold").setFontSize(14);
      row++;
      
      healthReport.recommendations.forEach(rec => {
        sheet.getRange(row, 1).setValue(`‚Ä¢ ${rec}`);
        row++;
      });
    }
    
    // Auto resize
    sheet.autoResizeColumn(1);
    sheet.autoResizeColumn(2);
    
    console.log(`‚úÖ Health report saved to sheet: ${sheet.getName()}`);
    
  } catch (error) {
    console.error(`‚ùå Error saving health report: ${error.toString()}`);
  }
}

function logErrorDetail(context, error) {
  try {
    const timestamp = new Date().toISOString();
    const errorDetails = {
      timestamp: timestamp,
      context: context,
      error: error.toString(),
      stack: error.stack || 'No stack trace',
      user: Session.getActiveUser().getEmail(),
      script: 'PPMA_SYNC_SYSTEM'
    };
    
    console.error(`‚ùå [${context}] ${error.toString()}`);
    
    // Simpan ke Error_Log sheet jika ada
    const errorSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Error_Log');
    if (errorSheet) {
      const lastRow = errorSheet.getLastRow() + 1;
      errorSheet.getRange(lastRow, 1).setValue(timestamp);
      errorSheet.getRange(lastRow, 2).setValue(context);
      errorSheet.getRange(lastRow, 3).setValue(error.toString());
      errorSheet.getRange(lastRow, 4).setValue(error.stack?.substring(0, 500) || 'No stack');
      errorSheet.getRange(lastRow, 5).setValue('SYSTEM');
    }
    
    // Kirim notifikasi untuk error kritis
    if (error.toString().includes('timeout') || 
        error.toString().includes('network') ||
        error.toString().includes('failed to fetch')) {
      SpreadsheetApp.getActiveSpreadsheet().toast(
        `‚ö†Ô∏è Error ${context}: ${error.toString().substring(0, 100)}`,
        'System Error',
        10
      );
    }
    
  } catch (logError) {
    console.error(`‚ùå Failed to log error: ${logError.toString()}`);
  }
}

// =============================================
// 14. FUNGSI PERBAIKAN DATA
// =============================================
function fixDataMuridValidation() {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Data_Murid');
    if (sheet) {
      sheet.getDataRange().clearDataValidations();
      Logger.log('‚úÖ Data Validation dihapus dari Data_Murid');
      
      SpreadsheetApp.getActiveSpreadsheet().toast(
        'Data Validation dihapus. Sync bisa dilanjutkan.',
        'Perbaikan Berhasil',
        5
      );
    }
  } catch (error) {
    Logger.log(`‚ùå Error: ${error.toString()}`);
  }
}

function fixExistingNotes() {
  try {
    console.log('üîß Memperbaiki notes yang sudah ada...');
    
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Data_Murid');
    if (!sheet || sheet.getLastRow() <= 1) {
      console.log('‚ÑπÔ∏è Tidak ada data di Data_Murid');
      return 'Tidak ada data';
    }
    
    const refData = getReferensiData();
    
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const refColumns = ['kelas_madin_id', 'kelas_quran_id', 'kamar_id'];
    
    let fixedCount = 0;
    let missingCount = 0;
    
    console.log('Headers ditemukan:', headers);
    console.log('Ref data keys:', Object.keys(refData));
    
    for (let row = 2; row <= sheet.getLastRow(); row++) {
      refColumns.forEach(col => {
        const colIndex = headers.indexOf(col);
        if (colIndex !== -1) {
          const cell = sheet.getRange(row, colIndex + 1);
          const id = cell.getValue();
          
          if (id) {
            let nama = null;
            const idStr = id.toString();
            
            if (refData[col] && refData[col][idStr]) {
              nama = refData[col][idStr];
            } else {
              const searchId = idStr.trim();
              if (refData[col]) {
                for (const [key, value] of Object.entries(refData[col])) {
                  if (key.toString().trim() === searchId) {
                    nama = value;
                    break;
                  }
                }
              }
            }
            
            if (nama) {
              cell.setNote(nama);
              fixedCount++;
              
              if (isNaN(id)) {
                const refSheetName = col === 'kelas_madin_id' ? 'Ref_KelasMadin' :
                                    col === 'kelas_quran_id' ? 'Ref_KelasQuran' : 'Ref_Kamar';
                const refSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(refSheetName);
                if (refSheet) {
                  const refDataArray = refSheet.getDataRange().getValues();
                  for (let i = 1; i < refDataArray.length; i++) {
                    if (refDataArray[i][1] === id) {
                      cell.setValue(refDataArray[i][0]);
                      break;
                    }
                  }
                }
              }
            } else {
              missingCount++;
              console.log(`‚ùå ${col} row ${row}: ID ${id} tidak ditemukan`);
            }
          }
        }
      });
      
      if (row % 50 === 0) {
        console.log(`üîÑ Processed ${row} rows...`);
      }
    }
    
    const result = `‚úÖ Fixed ${fixedCount} notes, ${missingCount} missing mappings`;
    console.log(result);
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `Perbaikan notes selesai: ${fixedCount} diperbaiki`,
      'Fix Notes',
      5
    );
    
    return result;
    
  } catch (error) {
    console.error(`‚ùå Fix notes error: ${error.toString()}`);
    return `ERROR: ${error.toString()}`;
  }
}

function fixKamarIdIssue() {
  try {
    console.log('üîß INFO: Fungsi fixKamarIdIssue sudah tidak diperlukan.');
    console.log('üìå Gunakan syncDataMuridWithNotes saja untuk sinkronisasi data.');
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Fungsi fixKamarIdIssue sudah digantikan oleh syncDataMuridWithNotes',
      'Info',
      5
    );
    
    // Tampilkan rekomendasi
    const ui = SpreadsheetApp.getUi();
    ui.alert(
      'INFO: Fungsi fixKamarIdIssue',
      'Fungsi ini sudah digantikan oleh "syncDataMuridWithNotes".\n\n' +
      'Lakukan:\n' +
      '1. Jalankan "syncDataMuridWithNotes" untuk sinkronisasi data murid\n' +
      '2. Edit data di sheet, perubahan akan otomatis tersinkron\n' +
      '3. Tidak perlu setup data validation manual',
      ui.ButtonSet.OK
    );
    
    return { success: true, message: 'Fungsi sudah digantikan' };
    
  } catch (error) {
    console.error(`‚ùå Error: ${error.toString()}`);
    return { success: false, error: error.toString() };
  }
}

function fixKamarIdData() {
  try {
    console.log('üîß Memperbaiki data kamar_id...');
    
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = spreadsheet.getSheetByName('Data_Murid');
    
    if (!sheet) {
      throw new Error('Sheet Data_Murid tidak ditemukan');
    }
    
    // 1. BACA DATA
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const kamarIdIndex = headers.indexOf('kamar_id');
    
    if (kamarIdIndex === -1) {
      console.log('‚ÑπÔ∏è Kolom kamar_id tidak ditemukan');
      return 'Kolom kamar_id tidak ditemukan';
    }
    
    // 2. AMBIL DATA REFERENSI KAMAR
    const kamarSheet = spreadsheet.getSheetByName('Ref_Kamar');
    const kamarMapping = {};
    
    if (kamarSheet && kamarSheet.getLastRow() > 1) {
      const kamarData = kamarSheet.getDataRange().getValues();
      for (let i = 1; i < kamarData.length; i++) {
        const id = kamarData[i][0]; // Kolom A: ID
        const nama = kamarData[i][1]; // Kolom B: Nama
        if (id && nama) {
          kamarMapping[nama] = id;
          // Juga mapping untuk berbagai variasi penulisan
          kamarMapping[nama.toUpperCase()] = id;
          kamarMapping[nama.toLowerCase()] = id;
          kamarMapping[nama.trim()] = id;
        }
      }
      console.log(`üìä Mapping kamar: ${Object.keys(kamarMapping).length} entri`);
    }
    
    // 3. PERBAIKI SETIAP BARIS
    let fixedCount = 0;
    let unchangedCount = 0;
    
    for (let i = 1; i < data.length; i++) {
      const currentValue = data[i][kamarIdIndex];
      
      if (!currentValue || currentValue === '') {
        continue; // Skip jika kosong
      }
      
      // Cek jika sudah berupa angka (ID)
      if (/^\d+$/.test(currentValue.toString().trim())) {
        unchangedCount++;
        continue;
      }
      
      // Coba cari mapping
      const strValue = currentValue.toString().trim();
      let foundId = null;
      
      // Cari exact match
      if (kamarMapping[strValue]) {
        foundId = kamarMapping[strValue];
      }
      // Cari partial match
      else {
        for (const [nama, id] of Object.entries(kamarMapping)) {
          if (strValue.includes(nama) || nama.includes(strValue)) {
            foundId = id;
            break;
          }
        }
      }
      
      // Update jika ditemukan
      if (foundId) {
        sheet.getRange(i + 1, kamarIdIndex + 1).setValue(foundId);
        fixedCount++;
        console.log(`üîÑ Baris ${i + 1}: "${strValue}" ‚Üí ${foundId}`);
      } else {
        console.log(`‚ö†Ô∏è Baris ${i + 1}: "${strValue}" tidak ada mapping`);
      }
    }
    
    console.log(`üìä Hasil: ${fixedCount} diperbaiki, ${unchangedCount} tidak berubah`);
    
    // Tampilkan hasil
    const ui = SpreadsheetApp.getUi();
    ui.alert(
      '‚úÖ Perbaikan kamar_id Selesai',
      `Data kamar_id telah diperbaiki:\n\n` +
      `‚úÖ ${fixedCount} data diperbaiki\n` +
      `‚ö™ ${unchangedCount} data sudah benar\n` +
      `üìä Total data: ${data.length - 1} baris`,
      ui.ButtonSet.OK
    );
    
    return `SUCCESS: ${fixedCount} kamar_id diperbaiki`;
    
  } catch (error) {
    console.error(`‚ùå Error fix kamar_id: ${error.toString()}`);
    return `ERROR: ${error.toString()}`;
  }
}

function fixAllIssues() {
  try {
    console.log('üîß Memulai perbaikan otomatis untuk semua issue...');
    
    // 1. Setup trigger jika tidak ada
    const triggers = ScriptApp.getProjectTriggers();
    const hasEditTrigger = triggers.some(t => t.getHandlerFunction().includes('onEdit'));
    
    if (!hasEditTrigger) {
      setupRealtimeEditTrigger();
      console.log('‚úÖ Edit trigger diaktifkan');
    }
    
    // 2. Sync data referensi
    syncReferensiData();
    console.log('‚úÖ Data referensi disinkronisasi');
    
    // 3. Setup data validation
    setupDataValidationForReferencesEnhanced();
    console.log('‚úÖ Data validation diatur');
    
    // 4. Fix kamar_id khusus
    fixKamarIdIssue();
    console.log('‚úÖ Masalah kamar_id diperbaiki');
    
    // 5. Sync data murid
    setTimeout(() => {
      syncDataMuridWithNotes();
    }, 3000);
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Semua perbaikan otomatis selesai! Sistem akan direfresh...',
      'Auto Fix Complete',
      8
    );
    
    // 6. Refresh halaman setelah 5 detik
    setTimeout(() => {
      SpreadsheetApp.getActiveSpreadsheet().toast(
        'Harap refresh halaman browser untuk melihat perubahan lengkap',
        'Refresh Needed',
        10
      );
    }, 5000);
    
    return { success: true, message: 'All issues fixed' };
    
  } catch (error) {
    console.error(`‚ùå Error in fixAllIssues: ${error.toString()}`);
    return { success: false, error: error.toString() };
  }
}

function fixNotesManual() {
  try {
    console.log('üîß Memperbaiki notes manual...');
    
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Data_Murid');
    if (!sheet) {
      throw new Error('Sheet Data_Murid tidak ditemukan');
    }
    
    // Refresh data referensi
    syncReferensiData();
    Utilities.sleep(3000);
    
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const refData = getReferensiData();
    
    const result = fillNotesInBatchEnhanced(sheet, headers, refData);
    
    const message = `‚úÖ Notes diperbaiki: ${result.notesAdded} notes ditambahkan`;
    console.log(message);
    
    SpreadsheetApp.getUi().alert(
      'Perbaikan Notes Selesai',
      `${message}\n\nProses: ${result.processed} baris\nNotes: ${result.notesAdded} ditambahkan`,
      SpreadsheetApp.getUi().ButtonSet.OK
    );
    
    return result;
    
  } catch (error) {
    const errorMsg = `‚ùå Fix notes gagal: ${error.toString()}`;
    console.error(errorMsg);
    SpreadsheetApp.getUi().alert('Error', errorMsg, SpreadsheetApp.getUi().ButtonSet.OK);
    return { error: errorMsg };
  }
}

function fixNotesManualEnhanced() {
  try {
    console.log('üîß Memperbaiki notes manual (enhanced)...');
    
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    
    // 1. Pastikan data referensi sudah sinkron
    syncReferensiData();
    Utilities.sleep(2000);
    
    // 2. Ambil data referensi
    const refData = getReferensiData();
    
    console.log('üìä Data referensi loaded:', {
      kelas_madin: Object.keys(refData.kelas_madin_id || {}).length,
      kelas_quran: Object.keys(refData.kelas_quran_id || {}).length,
      kamar: Object.keys(refData.kamar_id || {}).length
    });
    
    // 3. Proses sheet Data_Murid
    const sheet = spreadsheet.getSheetByName('Data_Murid');
    if (!sheet) {
      throw new Error('Sheet Data_Murid tidak ditemukan');
    }
    
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const result = fillNotesInBatchEnhanced(sheet, headers, refData);
    
    const message = `‚úÖ Notes diperbaiki: ${result.notesAdded} notes ditambahkan`;
    console.log(message);
    
    SpreadsheetApp.getUi().alert(
      'Perbaikan Notes Enhanced',
      `${message}\n\n` +
      `üìä Hasil:\n` +
      `‚Ä¢ Baris diproses: ${result.processed}\n` +
      `‚Ä¢ Notes ditambahkan: ${result.notesAdded}\n` +
      `‚Ä¢ Notes sudah ada: ${result.processed - result.notesAdded}`,
      SpreadsheetApp.getUi().ButtonSet.OK
    );
    
    return result;
    
  } catch (error) {
    const errorMsg = `‚ùå Fix notes enhanced gagal: ${error.toString()}`;
    console.error(errorMsg);
    SpreadsheetApp.getUi().alert('Error', errorMsg, SpreadsheetApp.getUi().ButtonSet.OK);
    return { error: errorMsg };
  }
}

function fixAllStructureWithID() {
  try {
    Logger.log('üîß Memperbaiki struktur kolom dengan ID yang benar...');
    
    const correctedStructures = {
      'Data_Murid': {
        columns: ['murid_id', 'nama', 'nis', 'nik', 'no_hp', 'alamat', 'nama_wali', 'no_wali', 'nilai', 'foto', 'kelas_madin_id', 'kelas_quran_id', 'kamar_id', 'created_at', 'updated_at'],
        primaryKey: 'murid_id'
      },
      'Data_Guru': {
        columns: ['guru_id', 'nama', 'nip', 'nik', 'jenis_kelamin', 'no_hp', 'alamat', 'jabatan', 'foto', 'created_at', 'updated_at'],
        primaryKey: 'guru_id'
      },
      'Data_Users': {
        columns: ['id', 'username', 'password', 'email', 'role', 'status', 'last_login', 'created_at', 'updated_at'],
        primaryKey: 'id'
      },
      'Data_Alumni': {
        columns: ['alumni_id', 'nama', 'nis', 'nik', 'no_hp', 'alamat', 'tahun_masuk', 'tahun_keluar', 'status_keluar', 'keterangan', 'pekerjaan', 'pendidikan_lanjut', 'foto', 'created_at', 'updated_at'],
        primaryKey: 'alumni_id'
      }
    };
    
    const results = [];
    
    for (const [sheetName, config] of Object.entries(correctedStructures)) {
      try {
        const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
        if (!sheet) {
          results.push(`‚ùå ${sheetName}: Sheet tidak ditemukan`);
          continue;
        }
        
        // Simpan data yang ada (jika ada)
        const existingData = sheet.getDataRange().getValues();
        const existingHeaders = existingData[0];
        
        // Buat mapping dari header lama ke baru
        const columnMapping = {};
        existingHeaders.forEach((header, index) => {
          if (header) {
            const cleanHeader = header.toString().trim().toLowerCase();
            
            // Mapping spesifik untuk kolom yang bermasalah
            if (cleanHeader.includes('kelas_madin') && !cleanHeader.includes('_id')) {
              columnMapping[index] = 'kelas_madin_id';
            } else if (cleanHeader.includes('kelas_quran') && !cleanHeader.includes('_id')) {
              columnMapping[index] = 'kelas_quran_id';
            } else if (cleanHeader.includes('kamar') && !cleanHeader.includes('_id')) {
              columnMapping[index] = 'kamar_id';
            } else if (cleanHeader === 'user_id' && sheetName === 'Data_Users') {
              columnMapping[index] = 'id';
            } else {
              columnMapping[index] = header;
            }
          }
        });
        
        // Clear sheet
        sheet.clear();
        
        // Set header baru
        sheet.getRange(1, 1, 1, config.columns.length).setValues([config.columns]);
        
        // Format header
        const headerRange = sheet.getRange(1, 1, 1, config.columns.length);
        headerRange.setFontWeight("bold")
                  .setBackground('#4CAF50')
                  .setFontColor('white');
        
        // Transfer data yang ada ke kolom baru (jika ada data)
        if (existingData.length > 1) {
          const newData = [];
          
          // Untuk setiap baris data (mulai dari baris 2)
          for (let row = 1; row < existingData.length; row++) {
            const newRow = [];
            
            // Untuk setiap kolom baru, cari data dari kolom lama
            config.columns.forEach(newCol => {
              let foundValue = '';
              
              // Cari di mapping kolom lama
              for (const [oldIndex, oldColName] of Object.entries(columnMapping)) {
                if (oldColName === newCol) {
                  foundValue = existingData[row][parseInt(oldIndex)];
                  break;
                }
              }
              
              newRow.push(foundValue);
            });
            
            newData.push(newRow);
          }
          
          // Tulis data yang sudah dipetakan
          if (newData.length > 0) {
            sheet.getRange(2, 1, newData.length, config.columns.length).setValues(newData);
          }
        }
        
        // Set format untuk kolom ID dan numeric
        config.columns.forEach((header, index) => {
          const colNumber = index + 1;
          const cleanHeader = header.toLowerCase();
          
          if (cleanHeader.includes('_id') || cleanHeader.includes('nik') || 
              cleanHeader.includes('nis') || cleanHeader.includes('nip') || 
              cleanHeader.includes('no_')) {
            const range = sheet.getRange(2, colNumber, Math.max(sheet.getLastRow()-1, 1), 1);
            range.setNumberFormat('@'); // Format text untuk mencegah scientific notation
          }
        });
        
        // Auto resize columns
        for (let col = 1; col <= config.columns.length; col++) {
          sheet.autoResizeColumn(col);
        }
        
        results.push(`‚úÖ ${sheetName}: Struktur diperbaiki (${config.columns.length} kolom)`);
        
      } catch (error) {
        results.push(`‚ùå ${sheetName}: ${error.toString()}`);
      }
    }
    
    const summary = results.join('\n');
    Logger.log(`üìä HASIL PERBAIKAN STRUKTUR:\n${summary}`);
    
    // Buat laporan
    const reportSheet = buatSummarySheet();
    reportSheet.clear();
    reportSheet.getRange(1, 1).setValue('üîß HASIL PERBAIKAN STRUKTUR KOLOM').setFontWeight("bold").setFontSize(16);
    
    let row = 3;
    results.forEach(result => {
      reportSheet.getRange(row, 1).setValue(result);
      row++;
    });
    
    reportSheet.autoResizeColumn(1);
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Perbaikan struktur selesai!',
      'Fix Structure',
      5
    );
    
    return { success: true, results };
    
  } catch (error) {
    const errorMsg = `‚ùå Perbaikan struktur gagal: ${error.toString()}`;
    Logger.log(errorMsg);
    return { success: false, error: errorMsg };
  }
}

function fixIdColumnsStructure() {
  try {
    Logger.log('üîß Memperbaiki struktur kolom ID...');
    
    const structureUpdates = {
      'Data_Murid': {
        primaryKey: 'murid_id',
        columns: ['murid_id', 'nama', 'nis', 'nik', 'no_hp', 'alamat', 'nama_wali', 'no_wali', 'foto', 'created_at', 'updated_at']
      },
      'Data_Guru': {
        primaryKey: 'guru_id', 
        columns: ['guru_id', 'nama', 'nip', 'nik', 'jenis_kelamin', 'no_hp', 'alamat', 'jabatan', 'foto', 'created_at', 'updated_at']
      },
      'Data_Users': {
        primaryKey: 'user_id',
        columns: ['user_id', 'username', 'password', 'email', 'role', 'status', 'last_login', 'created_at', 'updated_at']
      },
      'Data_Alumni': {
        primaryKey: 'alumni_id',
        columns: ['alumni_id', 'nama', 'nis', 'nik', 'no_hp', 'alamat', 'tahun_lulus', 'pekerjaan', 'perguruan_tinggi', 'foto', 'created_at', 'updated_at']
      }
    };
    
    const results = [];
    
    for (const [sheetName, config] of Object.entries(structureUpdates)) {
      try {
        const sheet = buatSheet(sheetName);
        
        // Set header dengan kolom yang tepat
        sheet.getRange(1, 1, 1, config.columns.length).setValues([config.columns]);
        
        // Format header
        const headerRange = sheet.getRange(1, 1, 1, config.columns.length);
        headerRange.setFontWeight("bold")
                  .setBackground('#4CAF50')
                  .setFontColor('white');
        
        // Set format untuk kolom ID dan numeric
        config.columns.forEach((header, index) => {
          const colNumber = index + 1;
          const cleanHeader = header.toLowerCase();
          
          if (cleanHeader.includes('_id') || cleanHeader.includes('nik') || 
              cleanHeader.includes('nis') || cleanHeader.includes('nip') || 
              cleanHeader.includes('no_')) {
            sheet.getRange(2, colNumber, sheet.getLastRow(), 1).setNumberFormat('@');
          }
        });
        
        // Auto resize
        for (let col = 1; col <= config.columns.length; col++) {
          sheet.autoResizeColumn(col);
        }
        
        results.push(`‚úÖ ${sheetName}: ${config.columns.length} kolom (PK: ${config.primaryKey})`);
        
      } catch (error) {
        results.push(`‚ùå ${sheetName}: ${error.toString()}`);
      }
    }
    
    const summary = results.join('\n');
    Logger.log(`üìä HASIL PERBAIKAN STRUKTUR ID:\n${summary}`);
    
    return { success: true, results };
    
  } catch (error) {
    const errorMsg = `‚ùå Perbaikan struktur ID gagal: ${error.toString()}`;
    Logger.log(errorMsg);
    return { success: false, error: errorMsg };
  }
}

function createManualStructure() {
  try {
    Logger.log('üèóÔ∏è Membuat struktur manual berdasarkan analisis...');
    
    // Struktur berdasarkan analisis database actual
    const structureDefinitions = {
      'Data_Murid': {
        headers: ['murid_id', 'nama', 'nis', 'nik', 'no_hp', 'alamat', 'nama_wali', 'no_wali', 'foto', 'created_at', 'updated_at'],
        color: '#4CAF50'
      },
      'Data_Guru': {
        headers: ['guru_id', 'nama', 'nip', 'nik', 'jenis_kelamin', 'no_hp', 'alamat', 'jabatan', 'foto', 'created_at', 'updated_at'],
        color: '#2196F3'
      },
      'Data_Users': {
        headers: ['user_id', 'username', 'password', 'email', 'role', 'status', 'last_login', 'created_at', 'updated_at'],
        color: '#FF5722'
      },
      'Data_Alumni': {
        headers: ['alumni_id', 'nama', 'nis', 'nik', 'no_hp', 'alamat', 'tahun_masuk', 'tahun_keluar', 'status_keluar', 'keterangan', 'pekerjaan', 'pendidikan_lanjut', 'foto', 'created_at', 'updated_at'],
        color: '#607D8B'
      }
    };
    
    const results = [];
    
    for (const [sheetName, config] of Object.entries(structureDefinitions)) {
      try {
        const sheet = SpreadsheetApp.getActiveSpreadsheet().insertSheet(sheetName);
        
        // Set headers
        sheet.getRange(1, 1, 1, config.headers.length).setValues([config.headers]);
        
        // Format headers
        const headerRange = sheet.getRange(1, 1, 1, config.headers.length);
        headerRange.setFontWeight("bold")
                  .setBackground(config.color)
                  .setFontColor('white');
        
        // Set column formats untuk numeric fields
        config.headers.forEach((header, index) => {
          const colNumber = index + 1;
          const cleanHeader = header.toLowerCase();
          
          if (cleanHeader.includes('_id') || cleanHeader.includes('nik') || 
              cleanHeader.includes('nis') || cleanHeader.includes('nip') || 
              cleanHeader.includes('no_')) {
            sheet.getRange(2, colNumber, 100, 1).setNumberFormat('@'); // Text format
          }
        });
        
        // Auto resize columns
        for (let col = 1; col <= config.headers.length; col++) {
          sheet.autoResizeColumn(col);
        }
        
        // Add sample data indicator
        sheet.getRange(2, 1).setValue('‚Üê Data akan muncul di sini setelah sync');
        sheet.getRange(2, 1).setFontColor('#999999').setFontStyle('italic');
        
        results.push(`‚úÖ ${sheetName}: ${config.headers.length} kolom dibuat`);
        
        Utilities.sleep(500);
        
      } catch (error) {
        results.push(`‚ùå ${sheetName}: ${error.toString()}`);
      }
    }
    
    Logger.log('üìä Hasil pembuatan struktur:\n' + results.join('\n'));
    return results;
    
  } catch (error) {
    Logger.log(`‚ùå Create manual structure failed: ${error.toString()}`);
    return [`‚ùå Error: ${error.toString()}`];
  }
}

// =============================================
// 15. FUNGSI VALIDATION & SETUP
// =============================================
function setupSimpleDataValidation(sheet, headers, refData) {
  try {
    const refColumns = ['kelas_madin_id', 'kelas_quran_id', 'kamar_id'];
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    
    refColumns.forEach(col => {
      const colIndex = headers.indexOf(col);
      if (colIndex !== -1) {
        const colNum = colIndex + 1;
        const lastRow = sheet.getLastRow();
        
        if (lastRow > 1) {
          const range = sheet.getRange(2, colNum, lastRow - 1, 1);
          
          const refSheetName = col === 'kelas_madin_id' ? 'Ref_KelasMadin' :
                              col === 'kelas_quran_id' ? 'Ref_KelasQuran' : 'Ref_Kamar';
          
          const refSheet = spreadsheet.getSheetByName(refSheetName);
          if (refSheet && refSheet.getLastRow() > 1) {
            const refRange = refSheet.getRange(2, 1, refSheet.getLastRow() - 1, 2);
            const rule = SpreadsheetApp.newDataValidation()
              .requireValueInRange(refRange, true)
              .setAllowInvalid(false)
              .setHelpText(`Pilih ${refSheetName} dari dropdown`)
              .build();
            
            range.setDataValidation(rule);
            console.log(`‚úÖ Data validation set for ${col}`);
          }
        }
      }
    });
    
    return true;
  } catch (error) {
    console.log(`‚ö†Ô∏è Setup data validation skipped: ${error.toString()}`);
    return false;
  }
}

function setupDataValidationForReferencesEnhanced() {
  try {
    console.log('üîß INFO: Data Validation sudah otomatis diatur oleh syncDataMuridWithNotes');
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Data Validation sudah otomatis diatur',
      'Info',
      5
    );
    
    return { success: true, message: 'Data validation sudah otomatis' };
    
  } catch (error) {
    console.error(`‚ùå Error: ${error.toString()}`);
    return { success: false, error: error.toString() };
  }
}

// =============================================
// 16. FUNGSI LOGGING ENHANCED
// =============================================
function setLogLevel(level) {
  CURRENT_LOG_LEVEL = level;
}

function logDebug(message) {
  if (CURRENT_LOG_LEVEL <= LOG_LEVELS.DEBUG) {
    Logger.log(`üîç [DEBUG] ${message}`);
  }
}

function logInfo(message) {
  if (CURRENT_LOG_LEVEL <= LOG_LEVELS.INFO) {
    Logger.log(`‚ÑπÔ∏è [INFO] ${message}`);
  }
}

function logWarn(message) {
  if (CURRENT_LOG_LEVEL <= LOG_LEVELS.WARN) {
    Logger.log(`‚ö†Ô∏è [WARN] ${message}`);
  }
}

function logError(message, error = null) {
  if (CURRENT_LOG_LEVEL <= LOG_LEVELS.ERROR) {
    const errorMsg = error ? `${message}: ${error.toString()}` : message;
    Logger.log(`‚ùå [ERROR] ${errorMsg}`);
    
    if (error && error.toString().includes('critical')) {
      SpreadsheetApp.getActiveSpreadsheet().toast(
        message,
        'Critical Error',
        10
      );
    }
  }
}

// =============================================
// 17. FUNGSI MENU & UI
// =============================================
function onOpen() {
  try {
    // Buat menu utama terpusat
    createUnifiedMainMenu();
    
    // Jalankan startup check setelah delay
    Utilities.sleep(3000);
    checkSystemHealthOnStartup();
    
  } catch (error) {
    console.log('‚ö†Ô∏è Error saat membuat menu: ' + error);
  }
}

function createUnifiedMainMenu() {
  const ui = SpreadsheetApp.getUi();
  
  const mainMenu = ui.createMenu('‚ö° PPMA SYNC SYSTEM');
  
  // ========== SUBMENU: SYNC DATA ==========
  const syncMenu = ui.createMenu('üì• Sync Data')
    .addItem('üîÑ Sync Lengkap (Aman)', 'jalankanSyncLengkapAman')
    .addItem('üìã Sync Murid dengan Notes', 'syncDataMuridWithNotesEnhancedAman')
    .addItem('üóÇÔ∏è Sync Referensi Data', 'syncReferensiData')
    .addSeparator()
    .addItem('üë®‚Äçüè´ Sync Data Guru', 'syncDataGuruViaAPI')
    .addItem('üë• Sync Data Users', 'syncDataUsersViaAPI')
    .addItem('üéì Sync Data Alumni', 'syncDataAlumniViaAPI');
  
  // ========== SUBMENU: TABEL BARU ==========
  const newTablesMenu = ui.createMenu('üìÖ Tabel Baru')
    .addItem('üîÑ Sync Semua Tabel Baru', 'syncTabelBaruAman')
    .addSeparator()
    .addItem('üìö Sync Jadwal Madin', 'syncDataJadwalMadinAman')
    .addItem('üìñ Sync Jadwal Quran', 'syncDataJadwalQuranAman')
    .addItem('üìÖ Sync Jadwal Kegiatan', 'syncDataJadwalKegiatanAman');
  
  // ========== SUBMENU: BACKUP & RESTORE ==========
  const backupMenu = ui.createMenu('üíæ Backup & Restore')
    .addItem('üîê Backup Data Murid', 'backupDataMuridEfisien')
    .addItem('üîÑ Sync dengan Backup', 'syncDataMuridDenganBackupAman')
    .addItem('‚Ü©Ô∏è Restore dari Backup', 'restoreDataMuridDariBackup')
    .addItem('üìä Cek Status Backup', 'cekStatusBackup')
    .addItem('üßπ Atur Jumlah Backup', 'setBackupSettings');
  
  // ========== SUBMENU: DIAGNOSIS & TOOLS ==========
  const toolsMenu = ui.createMenu('üîß Diagnosis & Tools')
    .addItem('ü©∫ System Diagnosis', 'diagnosaSistemLengkap')
    .addItem('üìä Quick Data Check', 'quickDataCheck')
    .addItem('üìà System Health Check', 'systemHealthCheck')
    .addItem('üìù Check Note Completeness', 'checkNoteCompleteness')
    .addItem('üìã Check Data Status', 'checkSyncStatus')
    .addSeparator()
    .addItem('üîç Diagnosa Struktur', 'diagnosaStrukturDatabase')
    .addItem('‚ùå Diagnosa Error Detail', 'diagnosaErrorDetail');
  
  // ========== SUBMENU: FIX & MAINTENANCE ==========
  const fixMenu = ui.createMenu('üîß Fix & Maintenance')
    .addItem('üìù Fix Notes Manual', 'fixNotesManualEnhanced')
    .addItem('‚úÖ Fix Existing Notes', 'fixExistingNotes')
    .addItem('üèóÔ∏è Fix Struktur Kolom', 'fixAllStructureWithID')
    .addItem('üßπ Cleanup Old Backups', 'cleanupOldBackupSheets');
  
  // ========== SUBMENU: SETUP & CONFIG ==========
  const setupMenu = ui.createMenu('‚öôÔ∏è Setup & Config')
    .addItem('‚ö° Activate Auto-Sync', 'setupSimpleEditTrigger')
    .addItem('üõ†Ô∏è Setup Sistem Lengkap', 'setupSistemLengkap')
    .addItem('‚ö° Setup Sistem Sederhana', 'setupSistemSederhana')
    .addItem('üìä Cek Status Trigger', 'checkAutoTriggersStatus');
  
  // ========== SUBMENU: TESTING ==========
  const testMenu = ui.createMenu('üß™ Testing')
    .addItem('üîó Test API Connection', 'testAPIConnection')
    .addItem('üèóÔ∏è Test Structure API', 'testStructureAPI')
    .addItem('üöÄ Test Push Data Murid', 'testDataMuridPush')
    .addItem('‚ö° Test Push Limited', 'testPushLimited')
    .addItem('üîç Quick Diagnosis', 'quickDiagnosis');
  
  // ========== SUBMENU: PUSH DATA ==========
  const pushMenu = ui.createMenu('üì§ Push Data')
    .addItem('üöÄ Push All Data Optimized', 'pushAllDataOptimized')
    .addItem('üìã Push Data dengan Mapping', 'pushDataWithMapping')
    .addItem('‚ö° Quick Push Test', 'quickPushTest')
    .addItem('üß™ Test Push Single Row', 'testPushSingleRow');
  
  // ========== BANGUN MENU UTAMA ==========
  mainMenu
    .addSubMenu(syncMenu)
    .addSubMenu(newTablesMenu)
    .addSubMenu(backupMenu)
    .addSubMenu(toolsMenu)
    .addSubMenu(fixMenu)
    .addSubMenu(setupMenu)
    .addSubMenu(testMenu)
    .addSubMenu(pushMenu)
    .addSeparator()
    .addItem('üìà Monitor Logs', 'monitorLogs')
    .addItem('‚ö° Quick Auto Sync', 'quickAutoSync')
    .addToUi();
  
  console.log('‚úÖ Menu utama terpusat berhasil dibuat');
}

function sendToApi(payload) {
  try {
    var options = {
      'method': 'post',
      'contentType': 'application/json',
      'payload': JSON.stringify(payload),
      'muteHttpExceptions': true
    };
    
    var response = UrlFetchApp.fetch(API_BASE_URL, options);
    var responseCode = response.getResponseCode();
    var responseText = response.getContentText();
    
    console.log(`üìä Response Code: ${responseCode}`);
    
    if (responseCode === 200) {
      var jsonResponse = JSON.parse(responseText);
      return {
        success: true,
        message: jsonResponse.message || 'Berhasil'
      };
    } else {
      return {
        success: false,
        message: `Error ${responseCode}: ${responseText}`
      };
    }
    
  } catch (error) {
    console.error('‚ùå Error sendToApi:', error);
    return {
      success: false,
      message: error.toString()
    };
  }
}

function jalankanSyncLengkap() {
  try {
    console.log('üöÄ Memulai sinkronisasi lengkap...');
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Memulai sinkronisasi lengkap...',
      'Sync System',
      3
    );
    
    // 1. Sync data referensi terlebih dahulu
    const refResults = syncReferensiData();
    console.log('‚úÖ Referensi data:', refResults);
    
    Utilities.sleep(2000);
    
    // 2. Sync data utama dengan notes
    const muridResult = syncDataMuridWithNotesEnhanced();
    console.log('‚úÖ Data murid:', muridResult);
    
    Utilities.sleep(2000);
    
    // 3. Sync data lainnya
    const results = [];
    
    const syncFunctions = [
      { name: 'Guru', func: syncDataGuruViaAPI },
      { name: 'Users', func: syncDataUsersViaAPI },
      { name: 'Alumni', func: syncDataAlumniViaAPI }
    ];
    
    syncFunctions.forEach(({ name, func }) => {
      try {
        const result = func();
        results.push(`${name}: ${result.includes('SUCCESS') ? '‚úÖ' : '‚ùå'}`);
        Utilities.sleep(1500);
      } catch (error) {
        results.push(`${name}: ‚ùå ${error.toString()}`);
      }
    });
    
    // 4. Setup trigger jika belum ada
    if (!checkEditTrigger()) {
      setupEditTrigger();
      results.push('Trigger: ‚úÖ Diaktifkan');
    }
    
    // 5. Tampilkan hasil
    const summary = `üìä HASIL SYNCRONISASI LENGKAP:\n\n` +
                   `‚Ä¢ Referensi: ${refResults.length} sheets\n` +
                   `‚Ä¢ Murid: ${muridResult.includes('SUCCESS') ? '‚úÖ' : '‚ùå'}\n` +
                   `${results.map(r => `‚Ä¢ ${r}`).join('\n')}\n\n` +
                   `Sistem siap digunakan!`;
    
    console.log(summary);
    
    const ui = SpreadsheetApp.getUi();
    ui.alert('‚úÖ Sinkronisasi Lengkap Selesai', summary, ui.ButtonSet.OK);
    
    return { success: true, results: [muridResult, ...results] };
    
  } catch (error) {
    const errorMsg = `‚ùå Sync lengkap gagal: ${error.toString()}`;
    console.error(errorMsg);
    
    const ui = SpreadsheetApp.getUi();
    ui.alert('‚ùå Sync Gagal', errorMsg, ui.ButtonSet.OK);
    
    return { success: false, error: errorMsg };
  }
}

// =============================================
// 18. FUNGSI NOTIFIKASI (dipanggil tapi tidak didefinisikan)
// =============================================
function sendHealthAlertEmail(report) {
  try {
    const recipient = Session.getActiveUser().getEmail();
    const timestamp = new Date().toLocaleString();
    
    let subject = `üö® PPMA System Alert - Health Check Failed`;
    let body = `PPMA SYSTEM HEALTH ALERT\n\n`;
    body += `‚ö†Ô∏è **SYSTEM ISSUES DETECTED**\n\n`;
    body += `Timestamp: ${timestamp}\n`;
    body += `Score: ${report.performance?.score || 0}/100\n`;
    body += `Issues: ${report.issues?.length || 0} total\n\n`;
    
    body += `üìã **ISSUE DETAILS**:\n`;
    if (report.issues && report.issues.length > 0) {
      report.issues.forEach(issue => {
        body += `‚Ä¢ ${issue.severity === 'HIGH' ? 'üî¥' : 'üü°'} ${issue.message}\n`;
      });
    }
    
    body += `\nüìä **SYSTEM STATS**:\n`;
    body += `‚Ä¢ Success Rate: ${report.statistics?.realtime?.successRate || 0}%\n`;
    body += `‚Ä¢ Total Errors: ${report.statistics?.errors?.totalErrors || 0}\n`;
    body += `‚Ä¢ Active Triggers: ${report.statistics?.system?.hasEditTrigger ? 'Yes' : 'No'}\n`;
    
    body += `\nüîó **SPREADSHEET**: ${SpreadsheetApp.getActiveSpreadsheet().getUrl()}\n`;
    body += `üë§ **USER**: ${Session.getActiveUser().getEmail()}\n\n`;
    
    body += `‚ö†Ô∏è This is an automated alert from PPMA Sync System\n`;
    
    MailApp.sendEmail({
      to: recipient,
      subject: subject,
      body: body
    });
    
    console.log(`üìß Health alert email sent to: ${recipient}`);
    
  } catch (error) {
    console.error(`‚ùå Failed to send health alert email: ${error.toString()}`);
  }
}

function sendAutoSyncNotification(subject, content) {
  try {
    const recipient = Session.getActiveUser().getEmail();
    const timestamp = new Date().toLocaleString();
    
    let body = `üìä NOTIFIKASI SISTEM PPMA\n\n`;
    body += `Waktu: ${timestamp}\n`;
    body += `User: ${recipient}\n`;
    body += `Spreadsheet: ${SpreadsheetApp.getActiveSpreadsheet().getName()}\n`;
    body += `\nüìã DETAIL:\n`;
    
    if (typeof content === 'string') {
      body += content;
    } else if (Array.isArray(content)) {
      body += content.join('\n');
    } else {
      body += JSON.stringify(content, null, 2);
    }
    
    body += `\n\nüîó Link Spreadsheet: ${SpreadsheetApp.getActiveSpreadsheet().getUrl()}`;
    body += `\n‚ö†Ô∏è Email ini dikirim otomatis oleh sistem PPMA`;
    
    MailApp.sendEmail({
      to: recipient,
      subject: `[PPMA AUTO] ${subject}`,
      body: body
    });
    
    Logger.log(`üìß Notifikasi email terkirim ke: ${recipient}`);
    
  } catch (error) {
    Logger.log(`‚ö†Ô∏è Gagal kirim email: ${error.toString()}`);
  }
}

// =============================================
// 19. FUNGSI SINKRONISASI TABEL BARU AMAN
// =============================================

function syncTabelBaruAman() {
  try {
    console.log('üöÄ Memulai sinkronisasi tabel baru (aman)...');
    
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    spreadsheet.toast('Memulai sync tabel baru...', 'Sync Aman', 3);
    
    const results = [];
    
    // Daftar tabel baru yang aman untuk disinkronisasi
    const tabelBaru = [
      { 
        name: 'Jadwal_Madin', 
        endpoint: 'get_jadwal_madin',
        sheetName: 'Data_Jadwal_Madin',
        color: '#3F51B5'
      },
      { 
        name: 'Jadwal_Quran', 
        endpoint: 'get_jadwal_quran',
        sheetName: 'Data_Jadwal_Quran',
        color: '#9C27B0'
      },
      { 
        name: 'Jadwal_Kegiatan', 
        endpoint: 'get_jadwal_kegiatan',
        sheetName: 'Data_Jadwal_Kegiatan',
        color: '#FF9800'
      },
      { 
        name: 'Absensi_Guru', 
        endpoint: 'get_absensi_guru',
        sheetName: 'Data_Absensi_Guru',
        color: '#795548'
      },
      { 
        name: 'Pengaturan_Absensi_Otomatis', 
        endpoint: 'get_pengaturan_absensi_otomatis',
        sheetName: 'Data_Pengaturan_Absensi_Otomatis',
        color: '#607D8B'
      },
      { 
        name: 'Login_Attempts', 
        endpoint: 'get_login_attempts',
        sheetName: 'Data_Login_Attempts',
        color: '#F44336'
      }
    ];
    
    // Proses setiap tabel baru
    for (const tabel of tabelBaru) {
      try {
        console.log(`üîÑ Syncing ${tabel.name}...`);
        spreadsheet.toast(`Sync ${tabel.name}...`, 'Progress', 2);
        
        const url = `${API_BASE_URL}?action=${tabel.endpoint}&limit=10000`;
        const options = {
          'muteHttpExceptions': true,
          'timeout': 30000
        };
        
        const response = UrlFetchApp.fetch(url, options);
        const result = JSON.parse(response.getContentText());
        
        if (result.success && result.data) {
          const data = result.data || [];
          
          if (data.length === 0) {
            results.push(`${tabel.name}: 0 data (kosong)`);
            continue;
          }
          
          // Buat sheet baru dengan nama unik untuk menghindari konflik
          const tempSheetName = `${tabel.sheetName}_TEMP_${new Date().getTime()}`;
          const tempSheet = spreadsheet.insertSheet(tempSheetName);
          
          // Get headers from first data row
          const headers = Object.keys(data[0]);
          
          // Set headers
          tempSheet.getRange(1, 1, 1, headers.length)
            .setValues([headers])
            .setFontWeight('bold')
            .setBackground(tabel.color)
            .setFontColor('white');
          
          // Fill data
          const rows = data.map(row => 
            headers.map(header => {
              let value = row[header] || '';
              
              // Format untuk numeric fields panjang
              if (isLongNumericField(header, value)) {
                value = formatForSheetDisplay(value);
              }
              
              return value;
            })
          );
          
          if (rows.length > 0) {
            tempSheet.getRange(2, 1, rows.length, headers.length).setValues(rows);
          }
          
          // Set column formats
          setColumnFormats(tempSheet, headers);
          
          // Auto resize semua kolom
          for (let col = 1; col <= headers.length; col++) {
            tempSheet.autoResizeColumn(col);
          }
          
          // Ganti sheet lama jika ada
          const oldSheet = spreadsheet.getSheetByName(tabel.sheetName);
          if (oldSheet) {
            spreadsheet.deleteSheet(oldSheet);
          }
          
          tempSheet.setName(tabel.sheetName);
          
          results.push(`${tabel.name}: ${data.length} data ‚úÖ`);
          
        } else {
          results.push(`${tabel.name}: Gagal - ${result.error || 'Unknown error'}`);
        }
        
        Utilities.sleep(2000); // Delay antar request
        
      } catch (error) {
        results.push(`${tabel.name}: Error - ${error.toString().substring(0, 50)}`);
        console.error(`‚ùå Error sync ${tabel.name}:`, error);
      }
    }
    
    // Tampilkan hasil
    const summary = `üìä HASIL SINKRONISASI TABEL BARU:\n\n` +
                   results.map(r => `‚Ä¢ ${r}`).join('\n') + 
                   `\n\n‚úÖ ${results.filter(r => r.includes('‚úÖ')).length}/${tabelBaru.length} berhasil` +
                   `\n\nüïê ${new Date().toLocaleString()}`;
    
    console.log(summary);
    
    // **PERBAIKAN: Tampilkan hasil di sheet SUMMARY bukan dialog UI**
    const sheet = buatSummarySheet();
    sheet.clear();
    
    let row = 1;
    sheet.getRange(row, 1).setValue('üìä HASIL SINKRONISASI TABEL BARU').setFontWeight("bold").setFontSize(16);
    row += 2;
    
    results.forEach(result => {
      if (result.includes('‚úÖ')) {
        sheet.getRange(row, 1).setValue(`‚Ä¢ ${result}`).setFontColor('#4CAF50');
      } else if (result.includes('‚ùå') || result.includes('Error')) {
        sheet.getRange(row, 1).setValue(`‚Ä¢ ${result}`).setFontColor('#FF0000');
      } else {
        sheet.getRange(row, 1).setValue(`‚Ä¢ ${result}`);
      }
      row++;
    });
    
    row++;
    sheet.getRange(row, 1).setValue(`üéØ ${results.filter(r => r.includes('‚úÖ')).length}/${tabelBaru.length} tabel berhasil disinkronisasi`);
    row++;
    sheet.getRange(row, 1).setValue(`üïê ${new Date().toLocaleString()}`);
    
    sheet.autoResizeColumn(1);
    
    // Tampilkan toast saja, tanpa dialog UI
    spreadsheet.toast(
      `Sync tabel baru selesai! ${results.filter(r => r.includes('‚úÖ')).length}/${tabelBaru.length} berhasil`,
      '‚úÖ Sync Tabel Baru',
      8
    );
    
    return { 
      success: true, 
      results 
    };
    
  } catch (error) {
    const errorMsg = `‚ùå Sync tabel baru gagal: ${error.toString()}`;
    console.error(errorMsg);
    
    SpreadsheetApp.getActiveSpreadsheet().toast(
      'Sync tabel baru gagal! Lihat log untuk detail.',
      'Error',
      5
    );
    
    return { success: false, error: errorMsg };
  }
}